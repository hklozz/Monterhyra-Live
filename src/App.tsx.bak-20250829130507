import React, { useState, useMemo, useRef, useImperativeHandle, useCallback } from 'react';
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { Edges, Text, useTexture } from '@react-three/drei';
import { Canvas, useThree } from '@react-three/fiber';
import { OrbitControls, Grid } from '@react-three/drei';
import * as THREE from 'three';
import { EspressoMachine, FlowerVase, CandyBowl } from './CounterItems';
import { WallShelf, ClothingRack, SpeakerOnStand } from './WallDecorations';
import { PricingCalculator } from './PricingModel';

const DESK_SIZES = [
  { label: '1m', width: 1 },
  { label: '2m', width: 2 },
  { label: '3m', width: 3 }
];

const COUNTER_TYPES = [
  { label: 'Ingen disk', width: 0, depth: 0 },
  { label: '1m disk', width: 1, depth: 0.5 },
  { label: '1,5m disk', width: 1.5, depth: 0.5 },
  { label: '2m disk', width: 2, depth: 0.5 },
  { label: '2,5m disk', width: 2.5, depth: 0.5 },
  { label: '3m disk', width: 3, depth: 0.5 },
  { label: '3,5m disk', width: 3.5, depth: 0.5 },
  { label: '4m disk', width: 4, depth: 0.5 },
  { label: 'L-disk (1,5m + 1m)', width: 0, depth: 0, type: 'L' },
  { label: 'L-disk spegelvänd (1,5m + 1m)', width: 0, depth: 0, type: 'L-mirrored' }
];

const TV_SIZES = [
  { label: 'Ingen', width: 0, height: 0 },
  { label: '43"', width: 0.96, height: 0.56 },
  { label: '55"', width: 1.22, height: 0.71 },
  { label: '70"', width: 1.56, height: 0.91 }
];

const TRUSS_TYPES = [
  { label: 'Ingen truss', type: 'none' },
  { label: 'Framkant truss (rak)', type: 'front-straight', width: 0.3, height: 0.3 },
  { label: 'Rund hängande truss', type: 'hanging-round', diameter: 2.0, height: 0.25 },
  { label: 'Fyrkantig hängande truss', type: 'hanging-square', width: 2.0, depth: 2.0, height: 0.25 }
] as const;

const STORAGE_TYPES = [
  { label: 'Inget förråd', width: 0, depth: 0 },
  { label: '1x1m förråd', width: 1, depth: 1 },
  { label: '2x1m förråd', width: 2, depth: 1 },
  { label: '3x1m förråd', width: 3, depth: 1 },
  { label: '4x1m förråd', width: 4, depth: 1 }
];

const PLANT_TYPES = [
  { label: 'Ficus', width: 0.4, depth: 0.4, height: 1.8, color: '#228B22', leafColor: '#32CD32', type: 'tree' },
  { label: 'Monstera', width: 0.6, depth: 0.6, height: 1.2, color: '#2F4F2F', leafColor: '#228B22', type: 'broad' },
  { label: 'Bambu', width: 0.3, depth: 0.3, height: 2.0, color: '#556B2F', leafColor: '#9ACD32', type: 'bamboo' },
  { label: 'Palmlilja', width: 0.5, depth: 0.5, height: 1.5, color: '#8FBC8F', leafColor: '#90EE90', type: 'palm' },
  { label: 'Olivträd', width: 0.7, depth: 0.7, height: 1.6, color: '#8B7355', leafColor: '#6B8E23', type: 'tree' },
  { label: 'Sansevieria', width: 0.3, depth: 0.3, height: 1.0, color: '#2F4F2F', leafColor: '#228B22', type: 'spiky' },
  { label: 'Kaktus', width: 0.2, depth: 0.2, height: 0.8, color: '#228B22', leafColor: '#32CD32', type: 'cactus' },
  { label: 'Rosmarin', width: 0.4, depth: 0.4, height: 0.6, color: '#556B2F', leafColor: '#9ACD32', type: 'herb' },
  { label: 'Lavendel', width: 0.5, depth: 0.5, height: 0.7, color: '#663399', leafColor: '#DDA0DD', type: 'flower' },
  { label: 'Eucalyptus', width: 0.8, depth: 0.8, height: 2.2, color: '#8FBC8F', leafColor: '#98FB98', type: 'tree' }
];

// Helper component: exposes a captureViews() method via ref that renders three camera positions
// into an offscreen render target and returns data URLs for each view.
const CaptureHelper = React.forwardRef((_, ref) => {
  // lazy require inside component to avoid SSR issues
  const { gl, scene, camera } = useThree();
  const originalCamera = camera as any;

  useImperativeHandle(ref, () => ({
    captureViews: (width = 1200, height = 800) => {
      // create a temporary render target
      const target = new THREE.WebGLRenderTarget(width, height);
      const prevRenderTarget = gl.getRenderTarget();
      const prevAspect = originalCamera.aspect;
      const results: string[] = [];

      const snapshots = [
        { pos: [0, 6, 0], lookAt: [0, 0, 0] }, // top-ish
        { pos: [0, 2, 6], lookAt: [0, 1, 0] }, // front
        { pos: [0, 2, 10], lookAt: [0, 1, 0] } // farther back
      ];

      const tmpCam = originalCamera.clone();

      for (const s of snapshots) {
        tmpCam.position.set(...s.pos as [number, number, number]);
        tmpCam.lookAt(new THREE.Vector3(...(s.lookAt as [number, number, number])));
        tmpCam.updateProjectionMatrix();
        gl.setSize(width, height);
        gl.setRenderTarget(target);
        gl.render(scene, tmpCam);
        const pixels = new Uint8Array(width * height * 4);
        gl.readRenderTargetPixels(target, 0, 0, width, height, pixels);
        // create canvas and copy pixels
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d')!;
        const imageData = ctx.createImageData(width, height);
        imageData.data.set(pixels);
        ctx.putImageData(imageData, 0, 0);
        // flip Y because readRenderTargetPixels gives bottom-up
        ctx.scale(1, -1);
        ctx.drawImage(canvas, 0, -height);
        results.push(canvas.toDataURL('image/png'));
      }

      // restore
      gl.setRenderTarget(prevRenderTarget);
      originalCamera.aspect = prevAspect;
      originalCamera.updateProjectionMatrix();
      target.dispose();

      return results;
    }
  }));

  return null;
});


const FURNITURE_TYPES = [
  { label: 'Barbord', width: 0.6, depth: 0.6, height: 1.1, color: '#FFFFFF', type: 'table' },
  { label: 'Barstol', width: 0.4, depth: 0.4, height: 1.0, color: '#FFFFFF', type: 'chair' },
  { label: 'Mysig pall', width: 0.35, depth: 0.35, height: 0.45, color: '#4169E1', type: 'stool' },
  { label: 'Soffa 2-sits', width: 1.4, depth: 0.8, height: 0.85, color: '#2F4F4F', type: 'sofa' },
  { label: 'Soffa 3-sits', width: 1.8, depth: 0.8, height: 0.85, color: '#2F4F4F', type: 'sofa' },
  { label: 'Fåtölj', width: 0.8, depth: 0.8, height: 0.9, color: '#8B4513', type: 'armchair' },
  { label: 'Sidobord', width: 0.5, depth: 0.5, height: 0.5, color: '#DEB887', type: 'side_table' }
];

const FLOOR_SIZES = [
  { label: '3x1,5', width: 3, depth: 1.5 },
  { label: '3x2', width: 3, depth: 2 },
  { label: '3x3', width: 3, depth: 3 },
  { label: '4x2', width: 4, depth: 2 },
  { label: '4x3', width: 4, depth: 3 },
  { label: '4x4', width: 4, depth: 4 },
  { label: '5x2', width: 5, depth: 2 },
  { label: '5x3', width: 5, depth: 3 },
  { label: '5x5', width: 5, depth: 5 },
  { label: '6x3', width: 6, depth: 3 },
  { label: '6x4', width: 6, depth: 4 },
  { label: '6x5', width: 6, depth: 5 },
  { label: '6x6', width: 6, depth: 6 },
  { label: '7x3', width: 7, depth: 3 },
  { label: '7x4', width: 7, depth: 4 },
  { label: '7x7', width: 7, depth: 7 },
  { label: '8x3', width: 8, depth: 3 },
  { label: '8x5', width: 8, depth: 5 },
  { label: '8x6', width: 8, depth: 6 },
  { label: '10x10', width: 10, depth: 10 },
  { label: 'Anpassad storlek', width: 0, depth: 0, custom: true }
];

const CARPET_COLORS = [
  { name: 'Ingen matta', color: null },
  { name: 'Gul', color: '#ffe066' },
  { name: 'Svart', color: '#222' },
  { name: 'Grå', color: '#888' },
  { name: 'Röd', color: '#ff4d4d' },
  { name: 'Orange', color: '#ffb300' },
  { name: 'Brun', color: '#8B5C2D' },
  { name: 'Grön', color: 'green' },
  { name: 'Beige', color: '#e2b878' },
  { name: 'Lila', color: '#a259d9' },
  { name: 'Vit', color: '#fff' },
  { name: 'Rutmönster Svart/Vit', color: 'checkerboard-bw' },
  { name: 'Rutmönster Röd/Svart', color: 'checkerboard-rb' },
  { name: 'Rutmönster Blå/Vit', color: 'checkerboard-bwhite' },
  { name: 'Rutmönster Gul/Svart', color: 'checkerboard-yb' }
];

const WALL_SHAPES = [
  { label: 'Inget valt', value: '' },
  { label: 'Rak', value: 'straight' },
  { label: 'L-form', value: 'l' },
  { label: 'U-form', value: 'u' }
];

const WALL_HEIGHTS = [
  { label: '2,5 m', value: 2.5 },
  { label: '3 m', value: 3 },
  { label: '3,5 m', value: 3.5 }
];

const GRAPHICS = [
  { label: 'Ej valt', value: 'none' },
  { label: 'Hyr grafik', value: 'hyr' },
  { label: 'Eget tryck (forex)', value: 'forex' },
  { label: 'Eget tryck (vepa)', value: 'vepa' }
];




function Floor({ 
  width, 
  depth, 
  onFloorClick 
}: { 
  width: number; 
  depth: number; 
  onFloorClick?: (x: number, z: number) => void;
}) {
  const tiles = [];
  const tileSize = 1; // basstorlek 1 meter

  // Räkna antal plattor i varje riktning och hantera partialplattor i kanten
  const xCount = Math.ceil(width / tileSize);
  const zCount = Math.ceil(depth / tileSize);
  const remWidth = width - Math.floor(width);
  const remDepth = depth - Math.floor(depth);

  // Kumulativ pos för att centrera exakt totala bredden/depth
  let cumX = 0;
  for (let ix = 0; ix < xCount; ix++) {
    const thisTileWidth = (ix === xCount - 1 && remWidth > 0) ? remWidth : tileSize;
    let cumZ = 0;
    for (let iz = 0; iz < zCount; iz++) {
      const thisTileDepth = (iz === zCount - 1 && remDepth > 0) ? remDepth : tileSize;

      // Positionera plattan relativt till total width/depth så allt centrerar korrekt
      const posX = -width / 2 + cumX + thisTileWidth / 2;
      const posZ = -depth / 2 + cumZ + thisTileDepth / 2;

      tiles.push(
        <mesh
          key={`${ix}-${iz}`}
          position={[posX, 0, posZ]}
          receiveShadow
          onClick={(e) => {
            if (onFloorClick) {
              e.stopPropagation();
              onFloorClick(posX, posZ);
            }
          }}
        >
          <boxGeometry args={[thisTileWidth, 0.12, thisTileDepth]} />
          <meshPhysicalMaterial color={"#fff"} roughness={0.9} metalness={0.1} />
          <Edges color="#ccc" />
        </mesh>
      );

      cumZ += thisTileDepth;
    }
    cumX += thisTileWidth;
  }
  
  return <>{tiles}</>;
}

function Carpet({ width, depth, color }: { width: number, depth: number, color: string }) {
  // Mattan ligger precis ovanpå golvet, centrerad
  
  // Hantera rutmönster
  if (color.startsWith('checkerboard-')) {
    let color1, color2;
    switch (color) {
      case 'checkerboard-bw':
        color1 = '#000000'; // Svart
        color2 = '#ffffff'; // Vit
        break;
      case 'checkerboard-rb':
        color1 = '#ff0000'; // Röd
        color2 = '#000000'; // Svart
        break;
      case 'checkerboard-bwhite':
        color1 = '#0000ff'; // Blå
        color2 = '#ffffff'; // Vit
        break;
      case 'checkerboard-yb':
        color1 = '#ffff00'; // Gul
        color2 = '#000000'; // Svart
        break;
      default:
        color1 = '#000000';
        color2 = '#ffffff';
    }

  // Skapa rutmönster-textur med 0.2m (20x20cm) rutor och centrera/aligna mot 0.2m-grid
    const checkerTexture = (() => {
      const canvas = document.createElement('canvas');
      const size = 256; // Bra upplösning
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d')!;

  // Vi ritar en enkel 2x2-enhet som representerar 2×2 små rutor (varje liten ruta blir en 20cm-square på golvet)
      const squareSizePx = size / 2;
      for (let x = 0; x < 2; x++) {
        for (let y = 0; y < 2; y++) {
          ctx.fillStyle = (x + y) % 2 === 0 ? color1 : color2;
          ctx.fillRect(x * squareSizePx, y * squareSizePx, squareSizePx, squareSizePx);
        }
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;

  // Ruta i verkligheten är 0.2m (20x20 cm)
  const squareSizeMeters = 0.2;
  // Antal 0.2m-rutor i varje riktning
  const squaresX = width / squareSizeMeters;
  const squaresZ = depth / squareSizeMeters;

  // Vi ritade en 2x2-enhet i canvas (fyra små rutor). Därför behöver
  // vi sätta texture.repeat till halva antalet 0.2m-rutor för att mappningen
  // ska ge korrekt antal rutor på golvet.
  const tilesPerCanvas = 2; // canvas innehåller 2 rutor per axel
  const repeatX = squaresX / tilesPerCanvas;
  const repeatZ = squaresZ / tilesPerCanvas;

  texture.repeat.set(repeatX, repeatZ);

  // Offset så mönstret centrerar mot mitten och alignar med 0.2m-grid
  // Vi tar fractional remainder för repeatX/repeatZ och halverar för centering
  const remX = (repeatX - Math.floor(repeatX)) / 2;
  const remZ = (repeatZ - Math.floor(repeatZ)) / 2;
  texture.offset.set(remX, remZ);

  // Säkerställ att texturen uppdateras och använder korrekt färgkodning
  (texture as any).encoding = (THREE as any).sRGBEncoding || (THREE as any).SRGBColorSpace || undefined;
  texture.magFilter = THREE.NearestFilter;
  texture.minFilter = THREE.NearestFilter;
  texture.needsUpdate = true;

      return texture;
    })();

    return (
      <mesh position={[0, 0.065, 0]}>
        <boxGeometry args={[width, 0.01, depth]} />
        <meshStandardMaterial map={checkerTexture} />
      </mesh>
    );
  }

  // Vanlig enfärgad matta
  return (
    <mesh position={[0, 0.065, 0]}>
      <boxGeometry args={[width, 0.01, depth]} />
      <meshStandardMaterial color={color} />
    </mesh>
  );
}

function ImageOverlay({ imageUrl, wallLength, wallHeight, position }: { 
  imageUrl: string, 
  wallLength: number, 
  wallHeight: number,
  position: [number, number, number]
}) {
  const texture = new THREE.TextureLoader().load(imageUrl);
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.ClampToEdgeWrapping;
  texture.flipY = true; // Flippa bilden rätt väg upp
  
  return (
    <mesh position={position} rotation={[0, 0, 0]}>
      <planeGeometry args={[wallLength, wallHeight]} />
      <meshStandardMaterial map={texture} side={THREE.DoubleSide} />
    </mesh>
  );
}

function ForexImageOverlay({ imageUrl, wallLength, wallHeight, position, rotation }: { 
  imageUrl: string, 
  wallLength: number, 
  wallHeight: number,
  position: [number, number, number],
  rotation?: [number, number, number]
}) {
  const texture = new THREE.TextureLoader().load(imageUrl);
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.ClampToEdgeWrapping;
  texture.flipY = true;
  
  const lists = [];
  const numLists = Math.floor(wallLength); // Antal lister (en mindre än antal meter)
  
  // Skapa silvriga lister varje meter
  for (let i = 1; i < numLists; i++) {
    const listPos = i - wallLength/2;
    
    // Justera listernas position baserat på väggtyp
    let listPosition: [number, number, number];
    let listGeometry: [number, number, number];
    
    if (rotation && Math.abs(rotation[1]) > 0) {
      // Sidovägg - listerna ska vara i z-led (djup av montern)
      listPosition = [0, 0, listPos];
      listGeometry = [0.008, wallHeight, 0.02]; // Tunnare i x-led
    } else {
      // Bakvägg - listerna ska vara i x-led (bredd av montern)
      listPosition = [listPos, 0, 0.005];
      listGeometry = [0.02, wallHeight, 0.008]; // Tunnare i z-led
    }
    
    // Använd boxGeometry istället för planeGeometry för bättre synlighet
    lists.push(
      <mesh 
        key={`list-${i}`}
        position={listPosition} 
        rotation={[0, 0, 0]}
      >
        <boxGeometry args={listGeometry} />
        <meshStandardMaterial 
          color="#d0d0d0" 
          metalness={0.8} 
          roughness={0.2} 
        />
      </mesh>
    );
  }
  
  return (
    <group position={position}>
      {/* Hela bilden som bakgrund */}
      <mesh rotation={rotation || [0, 0, 0]}>
        <planeGeometry args={[wallLength, wallHeight]} />
        <meshStandardMaterial map={texture} side={THREE.DoubleSide} />
      </mesh>
      {/* Silvriga lister ovanpå */}
      {lists}
    </group>
  );
}

function Plant({ plantConfig, position, rotation }: { 
  plantConfig: any, 
  position: [number, number, number],
  rotation: number
}) {
  const potHeight = 0.3;
  const potRadius = plantConfig.width / 2 - 0.05;
  // Small image-based renderer for photographic plants (cutout plane)
  function PlantImage({ url, w, h }: { url: string, w: number, h: number }) {
    // useTexture handles caching
    // @ts-ignore
    const tex: any = useTexture(url);
    if (tex) {
      tex.flipY = false;
      // set encoding in a type-safe-avoiding way
      (tex as any).encoding = (THREE as any).sRGBEncoding || 3000;
    }
    return (
      <group>
        {/* Front image */}
        <mesh position={[0, h/2 + 0.02, 0]} renderOrder={1}>
          <planeGeometry args={[w, h]} />
          <meshStandardMaterial map={tex} transparent={true} alphaTest={0.4} side={THREE.DoubleSide} depthWrite={false} />
        </mesh>
        {/* Backface subtle darkening to give volume */}
        <mesh position={[0, h/2 + 0.02, -0.005]} rotation={[0, Math.PI, 0]}>
          <planeGeometry args={[w*0.98, h*0.98]} />
          <meshStandardMaterial color="#0b3a0b" opacity={0.85} transparent={true} side={THREE.DoubleSide} depthWrite={false} />
        </mesh>
      </group>
    );
  }
      {/* SUPERREALISTISKA VÄXTER */}
      {/* If we have a photographic asset for this label, prefer that for extra realism. Place images in public/models/plants/<name>.png */}
      {(() => {
        const lbl = (plantConfig.label || '').toLowerCase();
        const mapping: Record<string,string> = {
          'drakträd': '/models/plants/dracaena.png',
          'dracaena': '/models/plants/dracaena.png',
          'ficus elastica': '/models/plants/ficus_elastica.png'
        };
        for (const key of Object.keys(mapping)) {
          if (lbl.includes(key)) {
            // scale image to approximate plantConfig dimensions
            const w = Math.max(plantConfig.width * 1.0, 0.4);
            const h = Math.max(plantConfig.height * 1.0, 0.9);
            return <PlantImage url={mapping[key]} w={w} h={h} />;
          }
        }
        return null;
      })()}
  
  return (
    <group position={position} rotation={[0, rotation * Math.PI / 180, 0]}>
      {/* Kruka */}
      <mesh position={[0, potHeight/2, 0]}>
        <cylinderGeometry args={[potRadius, potRadius * 0.8, potHeight, 12]} />
        <meshStandardMaterial color="#8B4513" roughness={0.8} />
      </mesh>
      
      {/* Jord */}
      <mesh position={[0, potHeight - 0.02, 0]}>
        <cylinderGeometry args={[potRadius * 0.95, potRadius * 0.95, 0.04, 12]} />
        <meshStandardMaterial color="#654321" roughness={1.0} />
      </mesh>
      
      {/* Växtstam/bas */}
      {plantConfig.type === 'tree' && (
        <mesh position={[0, potHeight + plantConfig.height/3, 0]}>
          <cylinderGeometry args={[0.02, 0.04, plantConfig.height/2, 8]} />
          <meshStandardMaterial color={plantConfig.color} roughness={0.9} />
        </mesh>
      )}
      
      {/* Växtblad baserat på typ */}
      {plantConfig.type === 'tree' && (
        <>
          {/* Krona för träd */}
          <mesh position={[0, potHeight + plantConfig.height * 0.75, 0]}>
            <sphereGeometry args={[plantConfig.width/3, 12, 8]} />
            <meshStandardMaterial color={plantConfig.leafColor} roughness={0.6} />
          </mesh>
          {/* Extra blad */}
          <mesh position={[plantConfig.width/4, potHeight + plantConfig.height * 0.65, plantConfig.width/4]}>
            <sphereGeometry args={[plantConfig.width/4, 8, 6]} />
            <meshStandardMaterial color={plantConfig.leafColor} roughness={0.6} />
          </mesh>
        </>
      )}
      
      {plantConfig.type === 'broad' && (
        <>
          {/* Stora breda blad för Monstera */}
          {[0, 1, 2, 3, 4].map(i => (
            <mesh 
              key={i}
              position={[
                Math.cos(i * Math.PI * 2 / 5) * plantConfig.width/3,
                potHeight + 0.2 + i * 0.15,
                Math.sin(i * Math.PI * 2 / 5) * plantConfig.width/3
              ]}
              rotation={[Math.PI/4, i * Math.PI * 2 / 5, 0]}
            >
              <planeGeometry args={[0.3, 0.4]} />
              <meshStandardMaterial color={plantConfig.leafColor} side={THREE.DoubleSide} roughness={0.5} />
            </mesh>
          ))}
        </>
      )}
      
      {plantConfig.type === 'bamboo' && (
        <>
          {/* Bambustavar */}
          {[0, 1, 2].map(i => (
            <mesh 
              key={i}
              position={[
                (i - 1) * 0.1,
                potHeight + plantConfig.height/2,
                (i - 1) * 0.05
              ]}
            >
              <cylinderGeometry args={[0.01, 0.01, plantConfig.height, 6]} />
              <meshStandardMaterial color={plantConfig.color} roughness={0.7} />
            </mesh>
          ))}
          {/* Bambublad */}
          {[0, 1, 2, 3, 4, 5].map(i => (
            <mesh 
              key={i}
              position={[
                Math.cos(i * Math.PI / 3) * 0.15,
                potHeight + plantConfig.height * 0.8 + Math.random() * 0.2,
                Math.sin(i * Math.PI / 3) * 0.15
              ]}
              rotation={[0, i * Math.PI / 3, Math.PI/6]}
            >
              <planeGeometry args={[0.15, 0.08]} />
              <meshStandardMaterial color={plantConfig.leafColor} side={THREE.DoubleSide} roughness={0.6} />
            </mesh>
          ))}
        </>
      )}
      
      {plantConfig.type === 'palm' && (
        <>
          {/* Palmstam */}
          <mesh position={[0, potHeight + plantConfig.height/2, 0]}>
            <cylinderGeometry args={[0.03, 0.05, plantConfig.height, 8]} />
            <meshStandardMaterial color={plantConfig.color} roughness={0.8} />
          </mesh>
          {/* Palmblad */}
          {[0, 1, 2, 3, 4, 5, 6, 7].map(i => (
            <mesh 
              key={i}
              position={[
                Math.cos(i * Math.PI / 4) * 0.3,
                potHeight + plantConfig.height * 0.9,
                Math.sin(i * Math.PI / 4) * 0.3
              ]}
              rotation={[Math.PI/3, i * Math.PI / 4, 0]}
            >
              <planeGeometry args={[0.4, 0.1]} />
              <meshStandardMaterial color={plantConfig.leafColor} side={THREE.DoubleSide} roughness={0.5} />
            </mesh>
          ))}
        </>
      )}
      
      {plantConfig.type === 'spiky' && (
        <>
          {/* Sansevieria blad */}
          {[0, 1, 2, 3, 4].map(i => (
            <mesh 
              key={i}
              position={[
                Math.cos(i * Math.PI * 2 / 5) * 0.08,
                potHeight + plantConfig.height/2,
                Math.sin(i * Math.PI * 2 / 5) * 0.08
              ]}
              rotation={[0, i * Math.PI * 2 / 5, 0]}
            >
              <boxGeometry args={[0.05, plantConfig.height, 0.02]} />
              <meshStandardMaterial color={plantConfig.leafColor} roughness={0.7} />
            </mesh>
          ))}
        </>
      )}
      
      {plantConfig.type === 'cactus' && (
        <>
          {/* Huvudkaktus */}
          <mesh position={[0, potHeight + plantConfig.height/2, 0]}>
            <cylinderGeometry args={[0.06, 0.08, plantConfig.height, 8]} />
            <meshStandardMaterial color={plantConfig.color} roughness={0.9} />
          </mesh>
          {/* Små sidoskott */}
          <mesh position={[0.08, potHeight + plantConfig.height * 0.3, 0]}>
            <cylinderGeometry args={[0.03, 0.04, plantConfig.height * 0.4, 6]} />
            <meshStandardMaterial color={plantConfig.color} roughness={0.9} />
          </mesh>
        </>
      )}
      
      {plantConfig.type === 'herb' && (
        <>
          {/* Små buskiga blad för rosmarin */}
          {Array.from({length: 20}).map((_, i) => (
            <mesh 
              key={i}
              position={[
                (Math.random() - 0.5) * plantConfig.width,
                potHeight + Math.random() * plantConfig.height,
                (Math.random() - 0.5) * plantConfig.depth
              ]}
              rotation={[Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI]}
            >
              <boxGeometry args={[0.02, 0.08, 0.01]} />
              <meshStandardMaterial color={plantConfig.leafColor} roughness={0.8} />
            </mesh>
          ))}
        </>
      )}
      
      {plantConfig.type === 'flower' && (() => {
        // Helper: create a soft petal/bud texture on an HTML canvas
        const createPetalTexture = (base: string, accent?: string) => {
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext('2d')!;
          // Background
          const g = ctx.createLinearGradient(0, 0, 0, 256);
          g.addColorStop(0, '#ffffff');
          g.addColorStop(0.25, base);
          g.addColorStop(1, '#222');
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, 256, 256);
          // Petal vein
          ctx.strokeStyle = accent || '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(128, 20);
          ctx.quadraticCurveTo(150, 128, 128, 236);
          ctx.stroke();
          // soft vignette
          ctx.globalCompositeOperation = 'overlay';
          const rg = ctx.createRadialGradient(128, 128, 10, 128, 128, 180);
          rg.addColorStop(0, 'rgba(255,255,255,0.15)');
          rg.addColorStop(1, 'rgba(0,0,0,0.25)');
          ctx.fillStyle = rg;
          ctx.fillRect(0, 0, 256, 256);
          const tex = new THREE.CanvasTexture(canvas);
          tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
          return tex;
        };

        // Lavender (detailed spikes)
        if (plantConfig.label && plantConfig.label.toLowerCase().includes('lavendel')) {
          return (
            <>
              {Array.from({length: 12}).map((_, si) => {
                const angle = si * Math.PI * 2 / 12;
                const stemX = Math.cos(angle) * 0.09;
                const stemZ = Math.sin(angle) * 0.09;
                return (
                  <group key={si} position={[stemX, 0, stemZ]}>
                    {/* stem */}
                    <mesh position={[0, potHeight + plantConfig.height/2, 0]}>
                      <cylinderGeometry args={[0.003, 0.004, plantConfig.height * 0.9, 6]} />
                      <meshStandardMaterial color="#3E5B2F" roughness={0.9} />
                    </mesh>
                    {/* spike of buds: many small spheres on a thin cylinder */}
                    {Array.from({length: 10}).map((_, bi) => (
                      <mesh
                        key={bi}
                        position={[0, potHeight + plantConfig.height * (0.6 + bi * 0.04), 0]}
                        rotation={[Math.random()*0.1, Math.random()*0.2, Math.random()*0.1]}
                        castShadow
                        receiveShadow
                      >
                        <sphereGeometry args={[0.007, 8, 6]} />
                        <meshStandardMaterial
                          color={'#9B59B6'}
                          emissive={'#7B3FA8'}
                          emissiveIntensity={0.05}
                          roughness={0.25}
                          metalness={0}
                        />
                      </mesh>
                    ))}
                  </group>
                );
              })}
            </>
          );
        }

        // Peace Lily (Fredens Lilja)
        if (plantConfig.label && plantConfig.label.toLowerCase().includes('fredens')) {
          const petalTex = createPetalTexture('#FFFFFF', '#F0F0F0');
          return (
            <>
              {/* broad glossy leaves */}
              {Array.from({length: 8}).map((_, i) => (
                <mesh
                  key={i}
                  position={[
                    Math.cos(i * Math.PI / 4) * (plantConfig.width/3 + Math.random()*0.06),
                    potHeight + 0.1 + Math.random()*plantConfig.height*0.3,
                    Math.sin(i * Math.PI / 4) * (plantConfig.width/3 + Math.random()*0.06)
                  ]}
                  rotation={[Math.PI/6 + Math.random()*0.2, i * Math.PI / 4 + Math.random()*0.4, Math.random()*0.2]}
                  receiveShadow
                  castShadow
                >
                  <planeGeometry args={[0.22, 0.36]} />
                  <meshStandardMaterial color={'#1E7F3B'} side={THREE.DoubleSide} roughness={0.25} map={createPetalTexture('#1E7F3B')} transparent opacity={0.95} />
                </mesh>
              ))}

              {/* Spathe / white flower */}
              {Array.from({length: 2}).map((_, fi) => (
                <group key={fi} position={[Math.cos(fi*Math.PI)*0.08, potHeight + plantConfig.height*0.65, Math.sin(fi*Math.PI)*0.08]}>
                  {/* spadix */}
                  <mesh position={[0, 0.06, 0]}>
                    <cylinderGeometry args={[0.006, 0.008, 0.16, 8]} />
                    <meshStandardMaterial color={'#F5E6C8'} roughness={0.6} />
                  </mesh>
                  {/* spathe (the white hood) */}
                  <mesh rotation={[Math.PI/2, 0, Math.PI/8]}>
                    <coneGeometry args={[0.06, 0.12, 24, 1, true]} />
                    <meshStandardMaterial map={petalTex} color={'#FFFBFA'} roughness={0.12} metalness={0.02} side={THREE.DoubleSide} transparent opacity={0.98} />
                  </mesh>
                </group>
              ))}
            </>
          );
        }

        // Generic flowering plant (layered petals)
        const petalTexture = createPetalTexture(plantConfig.leafColor || '#F08080', '#FFF');
        return (
          <>
            {/* short stems */}
            {Array.from({length: 5}).map((_, si) => (
              <mesh key={si} position={[Math.cos(si*Math.PI*2/5)*0.07, potHeight + plantConfig.height*0.35, Math.sin(si*Math.PI*2/5)*0.07]}>
                <cylinderGeometry args={[0.003, 0.004, plantConfig.height*0.6, 6]} />
                <meshStandardMaterial color={'#356B2A'} roughness={0.9} />
              </mesh>
            ))}

            {/* central flower: layered petals made from planes */}
            <group position={[0, potHeight + plantConfig.height*0.85, 0]}>
              {Array.from({length: 10}).map((_, pi) => (
                <mesh
                  key={pi}
                  rotation={[Math.PI/2, (pi/10)*Math.PI*2 + (pi%2?0.08:-0.08), 0]}
                  position={[Math.cos((pi/10)*Math.PI*2)*0.02, 0, Math.sin((pi/10)*Math.PI*2)*0.02]}
                  receiveShadow castShadow
                >
                  <planeGeometry args={[0.08 - (pi*0.003), 0.18 - (pi*0.01)]} />
                  <meshStandardMaterial map={petalTexture} color={plantConfig.leafColor} side={THREE.DoubleSide} roughness={0.18} transparent opacity={0.98} />
                </mesh>
              ))}
              {/* center stigma */}
              <mesh>
                <sphereGeometry args={[0.01, 8, 6]} />
                <meshStandardMaterial color={'#FFD166'} roughness={0.2} emissive={'#FFB84D'} emissiveIntensity={0.06} />
              </mesh>
            </group>
          </>
        );
      })()}
    </group>
  );
}

function StorageWall({ position, args, color, image, wallType, selectedWalls, storageTexture }: { 
  position: [number, number, number], 
  args: [number, number, number],
  color: string,
  image: string | null,
  wallType: 'back' | 'left' | 'right' | 'front',
  selectedWalls: { back: boolean; left: boolean; right: boolean; front: boolean; },
  storageTexture: THREE.Texture | null
}) {
  const shouldShowImage = image && selectedWalls[wallType];

  return (
    <mesh position={position}>
      <boxGeometry args={args} />
      <meshStandardMaterial 
        color={shouldShowImage ? "#ffffff" : color}
        map={shouldShowImage ? storageTexture : null}
        side={THREE.DoubleSide}
        roughness={0.3}
        metalness={0.1}
        transparent={shouldShowImage ? true : false}
        depthWrite={shouldShowImage ? false : true}
        polygonOffset={shouldShowImage ? true : false}
        polygonOffsetFactor={shouldShowImage ? -1 : 0}
        polygonOffsetUnits={shouldShowImage ? -1 : 0}
      />
    </mesh>
  );
}

function Furniture({ furnitureConfig, position, rotation }: { 
  furnitureConfig: any, 
  position: [number, number, number],
  rotation: number
}) {
  const baseHeight = 0.065; // Samma som mattan

  return (
    <group position={position} rotation={[0, rotation * Math.PI / 180, 0]}>
      {/* Barbord */}
      {furnitureConfig.type === 'table' && (
        <>
          {/* Stålben (slutar under bordsskivan) */}
          <mesh position={[0, baseHeight + furnitureConfig.height/2 - 0.025, 0]}>
            <cylinderGeometry args={[0.03, 0.05, furnitureConfig.height - 0.05, 8]} />
            <meshStandardMaterial color="#C0C0C0" roughness={0.2} metalness={0.8} />
          </mesh>
          {/* Bordsskiva */}
          <mesh position={[0, baseHeight + furnitureConfig.height - 0.025, 0]}>
            <cylinderGeometry args={[furnitureConfig.width/2, furnitureConfig.width/2, 0.05, 16]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.3} />
          </mesh>
          {/* Fotring */}
          <mesh position={[0, baseHeight + 0.3, 0]}>
            <torusGeometry args={[furnitureConfig.width/3, 0.02, 8, 16]} />
            <meshStandardMaterial color="#C0C0C0" roughness={0.2} metalness={0.8} />
          </mesh>
        </>
      )}

      {/* Barstol */}
      {furnitureConfig.type === 'chair' && (
        <>
          {/* Stålben (slutar under sitsen) */}
          <mesh position={[0, baseHeight + 0.32, 0]}>
            <cylinderGeometry args={[0.025, 0.04, 0.64, 8]} />
            <meshStandardMaterial color="#C0C0C0" roughness={0.2} metalness={0.8} />
          </mesh>
          {/* Sits */}
          <mesh position={[0, baseHeight + 0.65, 0]}>
            <cylinderGeometry args={[furnitureConfig.width/2.5, furnitureConfig.width/2.5, 0.05, 16]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.7} />
          </mesh>
          {/* Ryggstöd */}
          <mesh position={[0, baseHeight + 0.85, furnitureConfig.width/4]} rotation={[Math.PI/12, 0, 0]}>
            <boxGeometry args={[furnitureConfig.width/2, 0.3, 0.03]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.7} />
          </mesh>
          {/* Fotring */}
          <mesh position={[0, baseHeight + 0.25, 0]}>
            <torusGeometry args={[furnitureConfig.width/3, 0.015, 8, 16]} />
            <meshStandardMaterial color="#C0C0C0" roughness={0.2} metalness={0.8} />
          </mesh>
        </>
      )}

      {/* Mysig pall */}
      {furnitureConfig.type === 'stool' && (
        <>
          {/* Mjuk överdel med rundare form */}
          <mesh position={[0, baseHeight + furnitureConfig.height - 0.05, 0]}>
            <cylinderGeometry args={[furnitureConfig.width/2.2, furnitureConfig.width/2.5, 0.1, 16]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.3} />
          </mesh>
          {/* Mjuk mellandel */}
          <mesh position={[0, baseHeight + furnitureConfig.height - 0.15, 0]}>
            <cylinderGeometry args={[furnitureConfig.width/2.5, furnitureConfig.width/3, 0.1, 16]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.4} />
          </mesh>
          {/* Bas med rundade hörn */}
          <mesh position={[0, baseHeight + furnitureConfig.height/2 - 0.1, 0]}>
            <cylinderGeometry args={[furnitureConfig.width/3, furnitureConfig.width/3.2, furnitureConfig.height - 0.25, 12]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.6} />
          </mesh>
        </>
      )}

      {/* Soffa */}
      {furnitureConfig.type === 'sofa' && (
        <>
          {/* Sits */}
          <mesh position={[0, baseHeight + 0.2, 0]}>
            <boxGeometry args={[furnitureConfig.width, 0.15, furnitureConfig.depth - 0.15]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.8} />
          </mesh>
          {/* Ryggstöd */}
          <mesh position={[0, baseHeight + 0.45, furnitureConfig.depth/2 - 0.08]}>
            <boxGeometry args={[furnitureConfig.width, 0.5, 0.15]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.8} />
          </mesh>
          {/* Armstöd */}
          <mesh position={[furnitureConfig.width/2 - 0.08, baseHeight + 0.35, 0]}>
            <boxGeometry args={[0.15, 0.3, furnitureConfig.depth - 0.15]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.8} />
          </mesh>
          <mesh position={[-furnitureConfig.width/2 + 0.08, baseHeight + 0.35, 0]}>
            <boxGeometry args={[0.15, 0.3, furnitureConfig.depth - 0.15]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.8} />
          </mesh>
        </>
      )}

      {/* Fåtölj */}
      {furnitureConfig.type === 'armchair' && (
        <>
          {/* Sits */}
          <mesh position={[0, baseHeight + 0.25, 0]}>
            <boxGeometry args={[furnitureConfig.width - 0.15, 0.15, furnitureConfig.depth - 0.15]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.8} />
          </mesh>
          {/* Ryggstöd */}
          <mesh position={[0, baseHeight + 0.5, furnitureConfig.depth/2 - 0.08]} rotation={[-Math.PI/15, 0, 0]}>
            <boxGeometry args={[furnitureConfig.width - 0.15, 0.5, 0.15]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.8} />
          </mesh>
          {/* Armstöd */}
          <mesh position={[furnitureConfig.width/2 - 0.08, baseHeight + 0.4, 0]}>
            <boxGeometry args={[0.15, 0.3, furnitureConfig.depth - 0.15]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.8} />
          </mesh>
          <mesh position={[-furnitureConfig.width/2 + 0.08, baseHeight + 0.4, 0]}>
            <boxGeometry args={[0.15, 0.3, furnitureConfig.depth - 0.15]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.8} />
          </mesh>
        </>
      )}

      {/* Sidobord */}
      {furnitureConfig.type === 'side_table' && (
        <>
          <mesh position={[0, baseHeight + furnitureConfig.height - 0.03, 0]}>
            <boxGeometry args={[furnitureConfig.width, 0.06, furnitureConfig.depth]} />
            <meshStandardMaterial color={furnitureConfig.color} roughness={0.3} />
          </mesh>
          {/* Ben */}
          {[-1, 1].map(x => (
            [-1, 1].map(z => (
              <mesh 
                key={`${x}-${z}`}
                position={[
                  x * (furnitureConfig.width/2 - 0.03),
                  baseHeight + furnitureConfig.height/2 - 0.03,
                  z * (furnitureConfig.depth/2 - 0.03)
                ]}
              >
                <boxGeometry args={[0.05, furnitureConfig.height - 0.06, 0.05]} />
                <meshStandardMaterial color={furnitureConfig.color} roughness={0.8} />
              </mesh>
            ))
          ))}
        </>
      )}
    </group>
  );
}

export default function App() {
  const captureRef = useRef<any>(null);
  const [counterSize, setCounterSize] = useState(DESK_SIZES[0].width);
  const [tvMarkersVisible, setTvMarkersVisible] = useState(false);
  const [tvs, setTvs] = useState<Array<{id: number, size: number, wall: string, position: number, orientation: 'landscape'|'portrait'}>>([]);
  const [nextTvId, setNextTvId] = useState(1);
  const [selectedTvMarker, setSelectedTvMarker] = useState<{wall: string, position: number} | null>(null);
  const [storages, setStorages] = useState<Array<{id: number, type: number, position: {x: number, z: number}, rotation: number}>>([]);
  const [storageMarkersVisible, setStorageMarkersVisible] = useState(false);
  const [nextStorageId, setNextStorageId] = useState(1);
  const [selectedStorageMarker, setSelectedStorageMarker] = useState<{x: number, z: number} | null>(null);
  const [floorIndex, setFloorIndex] = useState<number|null>(null);
  const [customFloorWidth, setCustomFloorWidth] = useState(3);
  const [customFloorDepth, setCustomFloorDepth] = useState(1.5);
  const [carpetIndex, setCarpetIndex] = useState(0);
  const [wallShape, setWallShape] = useState('');
  const [wallHeight, setWallHeight] = useState(WALL_HEIGHTS[0].value);
  const [graphic, setGraphic] = useState('none');
  const [showLights, setShowLights] = useState(false);
  const [uploadedImage, setUploadedImage] = useState<string | null>(null);
  const [uploadedImageLeft, setUploadedImageLeft] = useState<string | null>(null);
  const [uploadedImageRight, setUploadedImageRight] = useState<string | null>(null);
  const [forexImageBack, setForexImageBack] = useState<string | null>(null);
  const [forexImageLeft, setForexImageLeft] = useState<string | null>(null);
  const [forexImageRight, setForexImageRight] = useState<string | null>(null);
  const [counters, setCounters] = useState<Array<{id: number, type: number, position: {x: number, z: number}, rotation: number}>>([]);
  const [counterMarkersVisible, setCounterMarkersVisible] = useState(false);
  const [nextCounterId, setNextCounterId] = useState(1);
  const [selectedMarkerPosition, setSelectedMarkerPosition] = useState<{x: number, z: number} | null>(null);
  const [selectedCounterType, setSelectedCounterType] = useState(1); // Vald disktyp
  const [selectedTvSize, setSelectedTvSize] = useState(1); // Vald TV-storlek
  const [selectedTrussType, setSelectedTrussType] = useState(0); // Vald truss-typ
  
  // Diskobjekt inställningar
  const [showEspressoMachine, setShowEspressoMachine] = useState(false);
  const [showFlowerVase, setShowFlowerVase] = useState(false);
  const [showCandyBowl, setShowCandyBowl] = useState(false);
  const [selectedStorageType, setSelectedStorageType] = useState(1); // Vald förråd-storlek
  
  // Nya placerbara funktioner
  const [showExtraPower, setShowExtraPower] = useState(false); // Endast för pris
  const [wallShelves, setWallShelves] = useState<Array<{id: number, wall: string, position: {x: number, y: number}}>>([]);
  const [shelfMarkersVisible, setShelfMarkersVisible] = useState(false);
  const [nextShelfId, setNextShelfId] = useState(1);
  const [showClothingRacks, setShowClothingRacks] = useState(false);
  const [speakers, setSpeakers] = useState<Array<{id: number, position: {x: number, z: number}, rotation: number}>>([]);
  const [speakerMarkersVisible, setSpeakerMarkersVisible] = useState(false);
  const [nextSpeakerId, setNextSpeakerId] = useState(1);
  const [speakerSize, setSpeakerSize] = useState<'small' | 'medium' | 'large'>('medium');
  
  // Mässmiljö toggle
  const [showExhibitionHall, setShowExhibitionHall] = useState(false);
  
  const [plants, setPlants] = useState<Array<{id: number, type: number, position: {x: number, z: number}, rotation: number}>>([]);
  const [plantMarkersVisible, setPlantMarkersVisible] = useState(false);
  const [nextPlantId, setNextPlantId] = useState(1);
  const [selectedPlantType, setSelectedPlantType] = useState(0); // Vald växttyp
  const [furniture, setFurniture] = useState<Array<{id: number, type: number, position: {x: number, z: number}, rotation: number}>>([]);
  const [furnitureMarkersVisible, setFurnitureMarkersVisible] = useState(false);
  const [nextFurnitureId, setNextFurnitureId] = useState(1);
  const [selectedFurnitureType, setSelectedFurnitureType] = useState(0); // Vald möbeltyp
  const [storageColor, setStorageColor] = useState('#BFBFBF'); // Förrådens färg
  const [storageGraphic, setStorageGraphic] = useState('none'); // Förrådens grafik
  const [storageUploadedImage, setStorageUploadedImage] = useState<string | null>(null);
  const [storageWallSelections, setStorageWallSelections] = useState({
    back: false,
    left: false,
    right: false,
    front: false
  }); // Vilka väggar som ska ha trycket
  
  // Diskars färginställningar
  const [counterPanelColor, setCounterPanelColor] = useState('#ffffff'); // Färg på diskpaneler (framsida + sidor)
  const [counterFrontImage, setCounterFrontImage] = useState<string | null>(null); // Eget tryck på framsidan
  
  // Optimerad textur-cache för att undvika fladdring
  const counterTexture = useMemo(() => {
    if (!counterFrontImage) return null;
    const loader = new THREE.TextureLoader();
    const texture = loader.load(counterFrontImage);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.flipY = true; // Explicit sätt flipY till true för korrekt orientering
    return texture;
  }, [counterFrontImage]);

  const storageTexture = useMemo(() => {
    if (!storageUploadedImage) return null;
    const loader = new THREE.TextureLoader();
    const texture = loader.load(storageUploadedImage);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    // texture.flipY = false; // Ta bort denna rad så bilden blir rätt håll
    return texture;
  }, [storageUploadedImage]);
  
  // Förberedd för framtida individuella väggbilder
  // const [storageImages, setStorageImages] = useState({
  //   back: null as string | null,
  //   left: null as string | null,
  //   right: null as string | null,
  //   front: null as string | null
  // }); // Olika bilder för olika väggar
  // Prevent "declared but never read" TS warnings for a few optional states used elsewhere
  // (kept as noop references so they don't alter behavior)
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const __unused_refs = [counterSize, setCounterSize, selectedTvMarker, setSelectedTvMarker, selectedStorageMarker, setSelectedStorageMarker, selectedMarkerPosition, setSelectedMarkerPosition];
  // Återställ markers när man byter tv-storlek eller antal
  // React.useEffect(() => { setTvMarkersVisible(true); }, [tvIndex, tvCount]);

  // Prisfunktion
  const calculatePrice = () => {
    let totalPrice = 0;
    
    if (floorIndex === null) return 0;
    
    const floorDimensions = (() => {
      const floorConfig = FLOOR_SIZES[floorIndex];
      if (floorConfig?.custom) {
        return { width: customFloorWidth, depth: customFloorDepth };
      }
      return { width: floorConfig.width, depth: floorConfig.depth };
    })();
    
    // Väggpriser (per 1m segment, varierar med höjd)
    let pricePerWallMeter = 862; // 2,5m som standard
    if (wallHeight === 3) pricePerWallMeter = 982;
    else if (wallHeight === 3.5) pricePerWallMeter = 1342;
    
    if (wallShape === 'straight') {
      // Rak vägg = baksida endast
      const backWallLength = floorDimensions.width;
      const numberOfWallSegments = Math.ceil((backWallLength * 2) ) / 2; // 0.5m segment, alltid uppåt
      totalPrice += numberOfWallSegments * pricePerWallMeter;
    } else if (wallShape === 'l') {
      // L-form = baksida + vänster sida
      const backWallLength = floorDimensions.width;
      const leftWallLength = floorDimensions.depth;
      const totalWallLength = backWallLength + leftWallLength;
      const numberOfWallSegments = Math.ceil((totalWallLength * 2) ) / 2;
      totalPrice += numberOfWallSegments * pricePerWallMeter;
    } else if (wallShape === 'u') {
      // U-form = baksida + vänster + höger sida
      const backWallLength = floorDimensions.width;
      const sideWallLength = floorDimensions.depth * 2; // båda sidorna
      const totalWallLength = backWallLength + sideWallLength;
      const numberOfWallSegments = Math.ceil((totalWallLength * 2) ) / 2;
      totalPrice += numberOfWallSegments * pricePerWallMeter;
    }
    
    // Matta/golvpriser (145 kr per kvm för färg, 255 kr för rutor)
    const floorArea = Math.round((floorDimensions.width * 100) * (floorDimensions.depth * 100)) / 10000; // alltid två decimaler
    if (carpetIndex > 0) { // Alla mattor utom "Ingen matta"
      const selectedCarpet = CARPET_COLORS[carpetIndex];
      if (selectedCarpet.color === 'checkerboard-bw') {
        // Rutmönster
        totalPrice += floorArea * 255;
      } else {
        // Färgmattor
        totalPrice += floorArea * 145;
      }
    }
    
    // Grafik
    if (graphic === 'hyr') {
      let pricePerMeter = 650; // 2,5m som standard
      if (wallHeight === 3) pricePerMeter = 950;
      if (wallHeight === 3.5) pricePerMeter = 1250;
      
      // Beräkna total väggyta som behöver grafik
      let totalWallLength = 0;
      if (wallShape === 'straight') totalWallLength = floorDimensions.width;
      else if (wallShape === 'l') totalWallLength = floorDimensions.width + floorDimensions.depth;
      else if (wallShape === 'u') totalWallLength = floorDimensions.width + (floorDimensions.depth * 2);
      
      totalPrice += totalWallLength * pricePerMeter;
    } else if (graphic === 'forex') {
      let pricePerMeter = 1450; // 2,5m som standard
      if (wallHeight === 3) pricePerMeter = 2000;
      if (wallHeight === 3.5) pricePerMeter = 2850;
      
      let totalWallLength = 0;
      if (wallShape === 'straight') totalWallLength = floorDimensions.width;
      else if (wallShape === 'l') totalWallLength = floorDimensions.width + floorDimensions.depth;
      else if (wallShape === 'u') totalWallLength = floorDimensions.width + (floorDimensions.depth * 2);
      
      totalPrice += totalWallLength * pricePerMeter;
    } else if (graphic === 'vepa') {
      // 700 kr per kvm
      let totalWallArea = 0;
      if (wallShape === 'straight') totalWallArea = floorDimensions.width * wallHeight;
      else if (wallShape === 'l') totalWallArea = (floorDimensions.width + floorDimensions.depth) * wallHeight;
      else if (wallShape === 'u') totalWallArea = (floorDimensions.width + (floorDimensions.depth * 2)) * wallHeight;
      
      totalPrice += totalWallArea * 700;
    }
    
    // TV-priser
    tvs.forEach(tv => {
      const tvConfig = TV_SIZES[tv.size];
      if (tvConfig.label === '43"') totalPrice += 2500;
      else if (tvConfig.label === '55"') totalPrice += 3500;
      else if (tvConfig.label === '70"') totalPrice += 11000;
    });
    
    // Diskpriser (baserat på 1m disk = 3500 kr + 760 kr per 0,5m steg)
    counters.forEach(counter => {
      const counterConfig = COUNTER_TYPES[counter.type];
      if (counterConfig.width === 1) totalPrice += 3500; // 1m disk
      else if (counterConfig.width === 1.5) totalPrice += 3500 + 760; // 1,5m disk (4260 kr)
      else if (counterConfig.width === 2) totalPrice += 3500 + 1520; // 2m disk (5020 kr)
      else if (counterConfig.width === 2.5) totalPrice += 3500 + 2280; // 2,5m disk (5780 kr)
      else if (counterConfig.width === 3) totalPrice += 3500 + 3040; // 3m disk (6540 kr)
      else if (counterConfig.width === 3.5) totalPrice += 3500 + 3800; // 3,5m disk (7300 kr)
      else if (counterConfig.width === 4) totalPrice += 3500 + 4560; // 4m disk (8060 kr)
      else if (counterConfig.type === 'L' || counterConfig.type === 'L-mirrored') {
        // L-disk har eget pris
        totalPrice += 8500;
      }
      
      // Om användaren valt en färg på diskpanelen så prissätts panelen som forex
      // (samma pris per kvm som forex-tryck). Vi approximera panelhöjd till 1.0m
      // och tar frontens area = width * panelHeight. För L-disk skippar vi detta.
      try {
        const FOREX_PRICE_PER_SQM = 1450; // kr per kvm
        const panelHeight = 1.0; // antagen panelhöjd i meter
        if (counterConfig.type !== 'L' && counterConfig.width > 0 && counterPanelColor && counterPanelColor.toLowerCase() !== '#ffffff') {
          const panelArea = counterConfig.width * panelHeight;
          const panelPrice = panelArea * FOREX_PRICE_PER_SQM;
          totalPrice += panelPrice;
        }
      } catch (e) {
        // ignore
      }
    });
    
    // Diskobjekt
    if (showEspressoMachine) totalPrice += 3500;
    if (showFlowerVase) totalPrice += 450;
    if (showCandyBowl) totalPrice += 250;
    
    // Förråd
    storages.forEach(storage => {
      const storageConfig = STORAGE_TYPES[storage.type];
      const FOREX_PRICE_PER_SQM = 1450;
      // Beräkna väggperimeter för förrådet (används för standardprissättning)
      const storageWallLength = (storageConfig.width * 2) + (storageConfig.depth * 2);

      if (storageColor && storageColor.toLowerCase() !== '#bfbfbf') {
        // När förrådet är färgat: prissätt baserat på de ytor som är exponerade mot öppet område.
        // Regler: Om förrådet ligger intill två väggar (t.ex. i ett hörn) tar vi bara betalt för de
        // två exponerade sidorna. Annars tar vi betalt för tre sidor (front + båda sidorna).
        // Vi detekterar om förrådet "rör" en vägg genom att jämföra position mot golvets kanter.
        const eps = 0.05; // tolerans i meter

        const backWallExists = wallShape === 'straight' || wallShape === 'l' || wallShape === 'u';
        const leftWallExists = wallShape === 'l' || wallShape === 'u';
        const rightWallExists = wallShape === 'u';

        const touchesBack = backWallExists && (storage.position.z >= (floorDimensions.depth / 2 - storageConfig.depth / 2 - eps));
        const touchesLeft = leftWallExists && (storage.position.x <= (-floorDimensions.width / 2 + storageConfig.width / 2 + eps));
        const touchesRight = rightWallExists && (storage.position.x >= (floorDimensions.width / 2 - storageConfig.width / 2 - eps));

        // Räkna exponerade sidor (front finns alltid exponerad eftersom det inte finns någon front-vägg)
        const exposedAreas: number[] = [];
        // front
        exposedAreas.push(storageConfig.width);
        // back
        if (!touchesBack) exposedAreas.push(storageConfig.width);
        // left
        if (!touchesLeft) exposedAreas.push(storageConfig.depth);
        // right
        if (!touchesRight) exposedAreas.push(storageConfig.depth);

        // Bestäm hur många sidor vi ska prissätta: om exponerade sidor <= 2 -> ta dem, annars ta 3
        let pricedArea = 0;
        if (exposedAreas.length <= 2) {
          pricedArea = exposedAreas.reduce((s, v) => s + v, 0);
        } else if (exposedAreas.length === 3) {
          pricedArea = exposedAreas.reduce((s, v) => s + v, 0);
        } else {
          // ExposedAreas === 4 (inget väggstöd) -> pris för 3 sidor. Vi väljer att inte ta betalt för baksidan
          // (antag att baksidan är minst synlig) => ta front + left + right
          const totalExposed = exposedAreas.reduce((s, v) => s + v, 0);
          pricedArea = totalExposed - storageConfig.width; // subtrahera baksidans bredd
        }

  const forexPrice = pricedArea * wallHeight * FOREX_PRICE_PER_SQM;
  // Applicera rabatt endast på förrådets standardväggspris (inte på forex-trycket)
  const numberOfWallSegments = Math.ceil((storageWallLength * 2)) / 2; // 0.5m segment
  const standardPrice = numberOfWallSegments * pricePerWallMeter;
  const discountedStandardPrice = standardPrice * 0.5; // 50% rabatt på förråd
  // Välj det lägsta av: oförändrat forex-pris (ingen rabatt) eller rabatterat standardpris
  const finalStoragePrice = Math.min(forexPrice, discountedStandardPrice);
  totalPrice += finalStoragePrice;
      } else {
        // Standard: beräkna väggpris baserat på löpmeter (samma som tidigare)
        const numberOfWallSegments = Math.ceil((storageWallLength * 2)) / 2; // 0.5m segment, alltid uppåt
        totalPrice += numberOfWallSegments * pricePerWallMeter;
      }
    });
    
    // Växter (850 kr per växt)
    totalPrice += plants.length * 850;
    
    // Möbler
    furniture.forEach(furnitureItem => {
      const furnitureConfig = FURNITURE_TYPES[furnitureItem.type];
      if (furnitureConfig.label === 'Barbord') totalPrice += 850;
      else if (furnitureConfig.label === 'Barstol') totalPrice += 550;
      else if (furnitureConfig.label === 'Mysig pall') totalPrice += 600;
      else if (furnitureConfig.label === 'Soffa 2-sits') totalPrice += 1350;
      else if (furnitureConfig.label === 'Soffa 3-sits') totalPrice += 1550;
      else if (furnitureConfig.label === 'Fåtölj') totalPrice += 850;
      else if (furnitureConfig.label === 'Sidobord') totalPrice += 380;
    });
    
    // Belysning
    if (showLights) {
      // Enkla lampor 300 kr varje
      let numberOfLights = 0;
      // Beräkna antal lampor baserat på väggarea, alltid räkna med halva meter
      if (wallShape === 'straight') numberOfLights = Math.ceil(floorDimensions.width * 2) / 2;
      else if (wallShape === 'l') numberOfLights = Math.ceil((floorDimensions.width + floorDimensions.depth) * 2) / 2;
      else if (wallShape === 'u') numberOfLights = Math.ceil((floorDimensions.width + (floorDimensions.depth * 2)) * 2) / 2;
      totalPrice += numberOfLights * 300;
    }
    
    // Truss
    const selectedTruss = TRUSS_TYPES[selectedTrussType];
    if (selectedTruss.type === 'front-straight') {
      totalPrice += floorDimensions.width * 370; // 370 kr per meter
    } else if (selectedTruss.type === 'hanging-round' && 'diameter' in selectedTruss) {
      const circumference = Math.PI * selectedTruss.diameter;
      totalPrice += circumference * 370;
    } else if (selectedTruss.type === 'hanging-square' && 'width' in selectedTruss) {
      const perimeter = (selectedTruss.width * 2) + (selectedTruss.depth * 2);
      totalPrice += perimeter * 370;
    }
    
    // Väggdekorationer
    wallShelves.forEach(() => {
      totalPrice += 550; // 550 kr per hylla
    });
    
    speakers.forEach(() => {
      if (speakerSize === 'small') totalPrice += 4500;
      else if (speakerSize === 'medium') totalPrice += 5500;
      else if (speakerSize === 'large') totalPrice += 8500;
    });
    
    if (showClothingRacks) {
      totalPrice += 550; // Klädhängare 550 kr
    }
    
    // Extra el
    if (showExtraPower) {
      totalPrice += 750;
    }
    
    return totalPrice;
  };

  // Arbetstidsberäkning för byggnation och rivning
  const calculateLaborCosts = () => {
    if (floorIndex === null) return { buildHours: 0, demolitionHours: 0, buildCost: 0, demolitionCost: 0, adminFee: 0, consumables: 0, persons: 2, area: 0 };
    
    const floorDimensions = (() => {
      const floorConfig = FLOOR_SIZES[floorIndex];
      if (floorConfig?.custom) {
        return { width: customFloorWidth, depth: customFloorDepth };
      }
      return { width: floorConfig.width, depth: floorConfig.depth };
    })();
    
    // Hitta närmaste standardstorlek för custom floors
    const getNearestStandardSize = (width: number, depth: number) => {
      const area = width * depth;
      const standardSizes = FLOOR_SIZES.filter(size => !size.custom);
      
      // Hitta närmaste större eller lika storlek
      const validSizes = standardSizes.filter(size => size.width * size.depth >= area);
      if (validSizes.length === 0) {
        // Om större än alla standardstorlekar, ta största
        return standardSizes[standardSizes.length - 1];
      }
      
      // Ta minsta av de giltiga storlekarna
      return validSizes.reduce((min, current) => 
        (current.width * current.depth) < (min.width * min.depth) ? current : min
      );
    };
    
    const effectiveSize = floorIndex !== null && FLOOR_SIZES[floorIndex]?.custom
      ? getNearestStandardSize(floorDimensions.width, floorDimensions.depth)
      : floorDimensions;
    
    // Bestäm antal personer och bastid baserat på storlek
    let persons = 2;
    let baseHours = 4; // Minst 4h
    
    const area = effectiveSize.width * effectiveSize.depth;
    
    if (area <= 9) {
      // 3x3 och mindre: 2 personer, 4h
      persons = 2;
      baseHours = 4;
    } else if (area <= 12) {
      // 3x4, 4x3: 2 personer, 6h
      persons = 2;
      baseHours = 6;
    } else if (area <= 16) {
      // 4x4: 2 personer, 8h
      persons = 2;
      baseHours = 8;
    } else if (area <= 25) {
      // 5x5 och mindre: 2 personer, 10h
      persons = 2;
      baseHours = 10;
    } else if (area <= 36) {
      // 6x6 och mindre: 2 personer, 12h
      persons = 2;
      baseHours = 12;
    } else {
      // Större än 6x6: 3 personer
      persons = 3;
      if (area <= 49) baseHours = 9; // 7x7: 3 personer, 9h
      else if (area <= 64) baseHours = 12; // 8x8: 3 personer, 12h
      else baseHours = 15; // 10x10+: 3 personer, 15h
    }
    
    let totalBuildHours = baseHours;
    
    // TV-tillägg: +1h per TV
    totalBuildHours += tvs.length;
    
    // Truss-tillägg: +6h (3×2h för 2 personer, eller 2×3h för 3 personer)
    const selectedTruss = TRUSS_TYPES[selectedTrussType];
    if (selectedTruss.type !== 'none') {
      totalBuildHours += 6;
    }
    
    // Beräkna total arbetstid (personer × timmar)
    const totalPersonHours = persons * totalBuildHours;
    const buildCost = totalPersonHours * 750; // 750 kr per timme
    
    // Rivning: 75% av byggtiden
    const demolitionHours = Math.round(totalBuildHours * 0.75);
    const totalDemolitionPersonHours = persons * demolitionHours;
    const demolitionCost = totalDemolitionPersonHours * 750;
    
    // Byråavgift baserat på storlek
    const adminFee = area <= 25 ? 5000 : 10000; // 5x5 och mindre = 5000kr, större = 10000kr
    
    // Förbrukningsmaterial baserat på monterstorlek
    let consumables = 750; // Små montrar som standard
    if (area <= 25) {
      consumables = 750; // Små montrar (≤5x5)
    } else if (area <= 64) {
      consumables = 1350; // Mellan montrar (5x5 - 8x8)
    } else {
      consumables = 2000; // Stora montrar (>8x8)
    }
    
    return {
      buildHours: totalBuildHours,
      demolitionHours,
      buildCost,
      demolitionCost,
      adminFee,
      consumables,
      persons,
      area: area
    };
  };
  
  // Återställ disk markers när man byter disktyp
  // React.useEffect(() => { 
  //   setCounterMarkersVisible(true); 
  //   setCounters([]);
  // }, [counterType]);

  return (
    <div data-unused={__unused_refs.length} style={{ width: '100vw', height: '100vh', background: '#f0f0f0', position: 'relative' }}>
      {/* Sidopanel */}
      <div style={{
        position: 'fixed',
        left: 0,
        top: 0,
        width: 300,
        height: '100vh',
        maxHeight: '100vh',
        boxSizing: 'border-box',
        background: 'rgba(245,245,250,0.98)',
        borderRight: '2px solid #bbb',
        boxShadow: '4px 0 16px #0002',
        padding: 28,
        paddingBottom: 56, // extra space so bottom controls (t.ex. Lampor) aren't hidden under edge
        display: 'flex',
        flexDirection: 'column',
        gap: 28,
        zIndex: 1000,
        overflowY: 'auto', // Lägg till scrollning
        overflowX: 'hidden',
        WebkitOverflowScrolling: 'touch'
      }}>
        <h2 style={{fontWeight:700, fontSize:22, marginBottom:8}}>Monterval</h2>
  {/* (Debug-info removed) */}
        <div>
          <label style={{ fontWeight: 600, marginRight: 8 }}>Golvyta:</label>
          <select value={floorIndex ?? ''} onChange={e => setFloorIndex(e.target.value === '' ? null : Number(e.target.value))}>
            <option value="">Välj storlek...</option>
            {FLOOR_SIZES.map((opt, i) => (
              <option key={opt.label} value={i}>{opt.label}</option>
            ))}
          </select>
        </div>
        
        {/* Anpassad storlek input-fält */}
        {floorIndex !== null && FLOOR_SIZES[floorIndex]?.custom && (
          <div style={{display: 'flex', gap: '10px', alignItems: 'center', marginTop: '10px'}}>
            <label style={{ fontWeight: 600 }}>Bredd:</label>
            <input 
              type="number" 
              value={customFloorWidth} 
              onChange={e => setCustomFloorWidth(Math.max(1, Math.min(15, parseFloat(e.target.value) || 1)))}
              step="0.5"
              min="1"
              max="15"
              style={{width: '60px', padding: '4px'}}
            />
            <span>m</span>
            <label style={{ fontWeight: 600, marginLeft: '15px' }}>Djup:</label>
            <input 
              type="number" 
              value={customFloorDepth} 
              onChange={e => setCustomFloorDepth(Math.max(1, Math.min(15, parseFloat(e.target.value) || 1)))}
              step="0.5"
              min="1" 
              max="15"
              style={{width: '60px', padding: '4px'}}
            />
            <span>m</span>
          </div>
        )}
        
        {floorIndex !== null && <>
        <div>
          <label style={{ fontWeight: 600, marginRight: 8 }}>Matta/färg:</label>
          <select value={carpetIndex} onChange={e => setCarpetIndex(Number(e.target.value))}>
            {CARPET_COLORS.map((opt, i) => (
              <option key={opt.name} value={i}>{opt.name}</option>
            ))}
          </select>
        </div>
        <div>
          <label style={{ fontWeight: 600, marginRight: 8 }}>Bakväggsform:</label>
          <select value={wallShape} onChange={e => setWallShape(e.target.value)}>
            {WALL_SHAPES.map(opt => (
              <option key={opt.value} value={opt.value}>{opt.label}</option>
            ))}
          </select>
        </div>
        <div>
          <label style={{ fontWeight: 600, marginRight: 8 }}>Vägg-höjd:</label>
          <select value={wallHeight} onChange={e => setWallHeight(Number(e.target.value))}>
            {WALL_HEIGHTS.map(opt => (
              <option key={opt.value} value={opt.value}>{opt.label}</option>
            ))}
          </select>
        </div>
        <div>
          <label style={{ fontWeight: 600, marginRight: 8 }}>Grafik:</label>
          <select value={graphic} onChange={e => setGraphic(e.target.value)}>
            {GRAPHICS.map(opt => (
              <option key={opt.value} value={opt.value}>{opt.label}</option>
            ))}
          </select>
        </div>
        {/* Lampor: flyttad placering i menyn - ligger nu under Grafik */}
        <div>
          <label style={{ fontWeight: 600, marginRight: 8 }}>Lampor:</label>
          <input 
            type="checkbox" 
            checked={showLights} 
            onChange={e => setShowLights(e.target.checked)}
            style={{ marginRight: 8 }}
          />
          <span>Visa LED-paneler i tak</span>
        </div>
        {graphic === 'vepa' && (
          <div>
            <label style={{ fontWeight: 600, marginBottom: 8, display: 'block' }}>Ladda upp egen bild för bakvägg:</label>
            <input 
              type="file" 
              accept="image/*"
              onChange={e => {
                const file = e.target.files?.[0];
                if (file) {
                  const reader = new FileReader();
                  reader.onload = (event) => {
                    setUploadedImage(event.target?.result as string);
                  };
                  reader.readAsDataURL(file);
                }
              }}
              style={{ fontSize: 12, marginBottom: 8 }}
            />
            {uploadedImage && (
              <div style={{ fontSize: 12, color: '#666' }}>✓ Bakväggsbild uppladdad</div>
            )}
            
            {(wallShape === 'l' || wallShape === 'u') && (
              <>
                <label style={{ fontWeight: 600, marginBottom: 8, display: 'block', marginTop: 16 }}>Ladda upp egen bild för vänster vägg:</label>
                <input 
                  type="file" 
                  accept="image/*"
                  onChange={e => {
                    const file = e.target.files?.[0];
                    if (file) {
                      const reader = new FileReader();
                      reader.onload = (event) => {
                        setUploadedImageLeft(event.target?.result as string);
                      };
                      reader.readAsDataURL(file);
                    }
                  }}
                  style={{ fontSize: 12, marginBottom: 8 }}
                />
                {uploadedImageLeft && (
                  <div style={{ fontSize: 12, color: '#666' }}>✓ Vänster väggbild uppladdad</div>
                )}
              </>
            )}
            
            {wallShape === 'u' && (
              <>
                <label style={{ fontWeight: 600, marginBottom: 8, display: 'block', marginTop: 16 }}>Ladda upp egen bild för höger vägg:</label>
                <input 
                  type="file" 
                  accept="image/*"
                  onChange={e => {
                    const file = e.target.files?.[0];
                    if (file) {
                      const reader = new FileReader();
                      reader.onload = (event) => {
                        setUploadedImageRight(event.target?.result as string);
                      };
                      reader.readAsDataURL(file);
                    }
                  }}
                  style={{ fontSize: 12, marginBottom: 8 }}
                />
                {uploadedImageRight && (
                  <div style={{ fontSize: 12, color: '#666' }}>✓ Höger väggbild uppladdad</div>
                )}
              </>
            )}
          </div>
        )}
        {graphic === 'forex' && (
          <div>
            <label style={{ fontWeight: 600, marginBottom: 8, display: 'block' }}>Ladda upp egen bild för bakvägg (forex med silvriga lister):</label>
            <input 
              type="file" 
              accept="image/*"
              onChange={e => {
                const file = e.target.files?.[0];
                if (file) {
                  const reader = new FileReader();
                  reader.onload = (event) => {
                    setForexImageBack(event.target?.result as string);
                  };
                  reader.readAsDataURL(file);
                }
              }}
              style={{ fontSize: 12, marginBottom: 8 }}
            />
            {forexImageBack && (
              <div style={{ fontSize: 12, color: '#666' }}>✓ Forex bakväggsbild uppladdad</div>
            )}
            
            {(wallShape === 'l' || wallShape === 'u') && (
              <>
                <label style={{ fontWeight: 600, marginBottom: 8, display: 'block', marginTop: 16 }}>Ladda upp egen bild för vänster vägg (forex):</label>
                <input 
                  type="file" 
                  accept="image/*"
                  onChange={e => {
                    const file = e.target.files?.[0];
                    if (file) {
                      const reader = new FileReader();
                      reader.onload = (event) => {
                        setForexImageLeft(event.target?.result as string);
                      };
                      reader.readAsDataURL(file);
                    }
                  }}
                  style={{ fontSize: 12, marginBottom: 8 }}
                />
                {forexImageLeft && (
                  <div style={{ fontSize: 12, color: '#666' }}>✓ Forex vänster väggbild uppladdad</div>
                )}
              </>
            )}
            
            {wallShape === 'u' && (
              <>
                <label style={{ fontWeight: 600, marginBottom: 8, display: 'block', marginTop: 16 }}>Ladda upp egen bild för höger vägg (forex):</label>
                <input 
                  type="file" 
                  accept="image/*"
                  onChange={e => {
                    const file = e.target.files?.[0];
                    if (file) {
                      const reader = new FileReader();
                      reader.onload = (event) => {
                        setForexImageRight(event.target?.result as string);
                      };
                      reader.readAsDataURL(file);
                    }
                  }}
                  style={{ fontSize: 12, marginBottom: 8 }}
                />
                {forexImageRight && (
                  <div style={{ fontSize: 12, color: '#666' }}>✓ Forex höger väggbild uppladdad</div>
                )}
              </>
            )}
          </div>
        )}
        <div>
          <label style={{ fontWeight: 600, marginRight: 8 }}>Diskar:</label>
          <div style={{fontSize:12, color:'#888', marginTop:4}}>
            🟢 <strong>Klicka på gröna rutor</strong> för att välja disktyp och placera. Du kan blanda olika typer!<br/>
            🔄 <strong>Klicka på placerad disk</strong> för att rotera den 90° åt gången.
          </div>
          {counters.length > 0 && (
            <div style={{fontSize:12, color:'#888', marginTop:8}}>
              Placerade diskar: {counters.length}
              <button
                style={{marginLeft:12, padding:'4px 12px', fontWeight:600, background:'#ff4444', color:'#fff', border:'none', borderRadius:4, cursor:'pointer', fontSize:12}}
                onClick={() => setCounters([])}
              >Rensa alla</button>
            </div>
          )}
          {/* Markörkontroller - visa alltid när väggar finns */}
          {wallShape && wallShape !== '' && (
            <div style={{fontSize:12, color:'#888', marginTop:8}}>
              {counterMarkersVisible ? (
                <>
                  <div style={{marginBottom:8}}>
                    <label style={{display:'block', marginBottom:4, fontWeight:600}}>Välj disktyp:</label>
                    <select 
                      value={selectedCounterType} 
                      onChange={(e) => setSelectedCounterType(Number(e.target.value))}
                      style={{width:'100%', padding:8, borderRadius:4, border:'1px solid #ccc'}}
                    >
                      {COUNTER_TYPES.slice(1).map((opt, index) => (
                        <option key={index} value={index + 1}>{opt.label}</option>
                      ))}
                    </select>
                  </div>
                  <span>Klicka på gröna rutor för att placera diskar. </span>
                  <button
                    style={{padding:'6px 18px', fontWeight:600, background:'#1ec94c', color:'#fff', border:'none', borderRadius:6, cursor:'pointer', fontSize:15}}
                    onClick={() => setCounterMarkersVisible(false)}
                  >OK</button>
                </>
              ) : (
                <>
                  <button
                    style={{padding:'8px 16px', fontWeight:600, background:'#007acc', color:'#fff', border:'none', borderRadius:6, cursor:'pointer', fontSize:14, marginTop:8}}
                    onClick={() => setCounterMarkersVisible(true)}
                  >Lägg till disk</button>
                </>
              )}
            </div>
          )}
          
          {/* Diskobjekt-kontroller */}
          <div style={{ marginTop: 12, padding: 8, backgroundColor: '#f9f9f9', borderRadius: 4 }}>
            <label style={{ fontWeight: 600, marginRight: 8, fontSize: 14 }}>Objekt på diskar:</label>
            <div style={{ fontSize: 12, color: '#666', marginTop: 4, marginBottom: 8 }}>
              Välj vilka objekt som ska visas på dina diskar. Smart placering anpassar sig efter diskstorlek.
            </div>
            
            <div style={{ display: 'flex', flexDirection: 'column', gap: 6 }}>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: 13 }}>
                <input 
                  type="checkbox" 
                  checked={showEspressoMachine} 
                  onChange={(e) => setShowEspressoMachine(e.target.checked)}
                  style={{ marginRight: 6 }}
                />
                ☕ Espressomaskin
              </label>
              
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: 13 }}>
                <input 
                  type="checkbox" 
                  checked={showFlowerVase} 
                  onChange={(e) => setShowFlowerVase(e.target.checked)}
                  style={{ marginRight: 6 }}
                />
                🌸 Vas med blomma
              </label>
              
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: 13 }}>
                <input 
                  type="checkbox" 
                  checked={showCandyBowl} 
                  onChange={(e) => setShowCandyBowl(e.target.checked)}
                  style={{ marginRight: 6 }}
                />
                🍬 Godiskål
              </label>
            </div>
          </div>
        </div>
        {wallShape && wallShape !== '' && (
          <div>
            <label style={{ fontWeight: 600, marginRight: 8 }}>TV-apparater:</label>
            <div style={{fontSize:12, color:'#888', marginTop:4}}>
              📺 <strong>Klicka på väggarna</strong> för att välja TV-storlek och placera. Du kan blanda olika storlekar!<br/>
              🔄 <strong>Dubbelklicka på placerad TV</strong> för att växla mellan liggande/stående format.
            </div>
            
            {tvs.length > 0 && (
              <div style={{fontSize:12, color:'#888', marginTop:8}}>
                Placerade TV:ar: {tvs.length}
                <button
                  style={{marginLeft:12, padding:'4px 12px', fontWeight:600, background:'#ff4444', color:'#fff', border:'none', borderRadius:4, cursor:'pointer', fontSize:12}}
                  onClick={() => setTvs([])}
                >Rensa alla</button>
              </div>
            )}
            
            {/* TV-kontroller */}
            <div style={{fontSize:12, color:'#888', marginTop:8}}>
              {tvMarkersVisible ? (
                <>
                  <div style={{marginBottom:8}}>
                    <label style={{display:'block', marginBottom:4, fontWeight:600}}>Välj TV-storlek:</label>
                    <select 
                      value={selectedTvSize} 
                      onChange={(e) => setSelectedTvSize(Number(e.target.value))}
                      style={{width:'100%', padding:8, borderRadius:4, border:'1px solid #ccc'}}
                    >
                      {TV_SIZES.slice(1).map((opt, index) => (
                        <option key={index} value={index + 1}>{opt.label}</option>
                      ))}
                    </select>
                  </div>
                  <span>Klicka på väggarna för att placera TV:ar. </span>
                  <button
                    style={{padding:'6px 18px', fontWeight:600, background:'#1ec94c', color:'#fff', border:'none', borderRadius:6, cursor:'pointer', fontSize:15}}
                    onClick={() => setTvMarkersVisible(false)}
                  >OK</button>
                </>
              ) : (
                <>
                  <button
                    style={{padding:'8px 16px', fontWeight:600, background:'#007acc', color:'#fff', border:'none', borderRadius:6, cursor:'pointer', fontSize:14, marginTop:8}}
                    onClick={() => setTvMarkersVisible(true)}
                  >Lägg till TV</button>
                </>
              )}
            </div>

            {/* Truss-kontroller */}
            <div style={{ marginTop: 16 }}>
              <label style={{ fontWeight: 600, marginRight: 8 }}>Truss-strukturer:</label>
              <div style={{ fontSize: 12, color: '#888', marginTop: 4 }}>
                🔩 <strong>Välj truss-typ</strong> för din monter.<br/>
                📐 <strong>Framkant:</strong> Rak truss längs framkanten.<br/>
                🎪 <strong>Hängande:</strong> Rund eller fyrkantig struktur i mitten.
              </div>
              
              <div style={{ marginTop: 8 }}>
                <label style={{ display: 'block', marginBottom: 4, fontWeight: 600 }}>Välj truss-typ:</label>
                <select 
                  value={selectedTrussType} 
                  onChange={(e) => setSelectedTrussType(Number(e.target.value))}
                  style={{ width: '100%', padding: 8, borderRadius: 4, border: '1px solid #ccc' }}
                >
                  {TRUSS_TYPES.map((opt, index) => (
                    <option key={index} value={index}>{opt.label}</option>
                  ))}
                </select>
              </div>
            </div>

          </div>
        )}
        <div>
          <label style={{ fontWeight: 600, marginRight: 8 }}>Förråd:</label>
          <div style={{fontSize:12, color:'#888', marginTop:4}}>
            📦 <strong>Klicka på gröna rutor</strong> för att välja förråd-storlek och placera.<br/>
            🔄 <strong>Klicka på placerat förråd</strong> för att rotera det 90° åt gången.
          </div>
          
          {storages.length > 0 && (
            <div style={{fontSize:12, color:'#888', marginTop:8}}>
              Placerade förråd: {storages.length}
              <button
                style={{marginLeft:12, padding:'4px 12px', fontWeight:600, background:'#ff4444', color:'#fff', border:'none', borderRadius:4, cursor:'pointer', fontSize:12}}
                onClick={() => setStorages([])}
              >Rensa alla</button>
            </div>
          )}
          
          {/* Förrådskontroller */}
          {wallShape && wallShape !== '' && (
            <div style={{fontSize:12, color:'#888', marginTop:8}}>
              {storageMarkersVisible ? (
                <>
                  <div style={{marginBottom:8}}>
                    <label style={{display:'block', marginBottom:4, fontWeight:600}}>Välj förråd-storlek:</label>
                    <select 
                      value={selectedStorageType} 
                      onChange={(e) => setSelectedStorageType(Number(e.target.value))}
                      style={{width:'100%', padding:8, borderRadius:4, border:'1px solid #ccc'}}
                    >
                      {STORAGE_TYPES.slice(1).map((opt, index) => (
                        <option key={index} value={index + 1}>{opt.label}</option>
                      ))}
                    </select>
                  </div>
                  <span>Klicka på blå rutor för att placera förråd. </span>
                  <button
                    style={{padding:'6px 18px', fontWeight:600, background:'#1ec94c', color:'#fff', border:'none', borderRadius:6, cursor:'pointer', fontSize:15}}
                    onClick={() => setStorageMarkersVisible(false)}
                  >OK</button>
                </>
              ) : (
                <>
                  <button
                    style={{padding:'8px 16px', fontWeight:600, background:'#007acc', color:'#fff', border:'none', borderRadius:6, cursor:'pointer', fontSize:14, marginTop:8}}
                    onClick={() => setStorageMarkersVisible(true)}
                  >Lägg till förråd</button>
                </>
              )}
            </div>
          )}
        </div>
        {/* Förrådsinställningar för färg och grafik */}
        {wallShape && wallShape !== '' && storages.length > 0 && (
          <div>
            <label style={{ fontWeight: 600, marginRight: 8 }}>Förrådens utseende:</label>
            
            <div style={{marginTop:8}}>
              <label style={{ fontWeight: 600, marginBottom: 4, display: 'block' }}>Färg på förråd:</label>
              <input
                type="color"
                value={storageColor}
                onChange={(e) => setStorageColor(e.target.value)}
                style={{ width: '100%', height: 30, border: '1px solid #ccc', borderRadius: 4 }}
              />
            </div>

            <div style={{marginTop:8}}>
              <label style={{ fontWeight: 600, marginBottom: 4, display: 'block' }}>Grafik på förråd:</label>
              <select 
                value={storageGraphic} 
                onChange={e => setStorageGraphic(e.target.value)}
                style={{width:'100%', padding:8, borderRadius:4, border:'1px solid #ccs'}}
              >
                <option value="none">Ingen grafik</option>
                <option value="upload">Ladda upp egen bild</option>
              </select>
            </div>
          </div>
        )}

        {/* Bildkontroller för förråd - visas alltid när vi har förråd och valt 'ladda upp' */}
        {storages.length > 0 && storageGraphic === 'upload' && (
          <div style={{marginTop:16}}>
            <label style={{ fontWeight: 600, marginRight: 8 }}>Förrådbilder:</label>
            
            <div style={{marginTop:8}}>
              <label style={{ fontWeight: 600, marginBottom: 8, display: 'block' }}>Välj vilka väggar som ska ha bilden:</label>
              
              <div style={{marginBottom:4}}>
                <label style={{display:'flex', alignItems:'center', fontSize:14}}>
                  <input 
                    type="checkbox" 
                    checked={storageWallSelections.back}
                    onChange={e => setStorageWallSelections(prev => ({...prev, back: e.target.checked}))}
                    style={{marginRight:8}}
                  />
                  Bakvägg (vägg mot publiken)
                </label>
              </div>
              
              <div style={{marginBottom:4}}>
                <label style={{display:'flex', alignItems:'center', fontSize:14}}>
                  <input 
                    type="checkbox" 
                    checked={storageWallSelections.left}
                    onChange={e => setStorageWallSelections(prev => ({...prev, left: e.target.checked}))}
                    style={{marginRight:8}}
                  />
                  Vänster vägg
                </label>
              </div>
              
              <div style={{marginBottom:4}}>
                <label style={{display:'flex', alignItems:'center', fontSize:14}}>
                  <input 
                    type="checkbox" 
                    checked={storageWallSelections.right}
                    onChange={e => setStorageWallSelections(prev => ({...prev, right: e.target.checked}))}
                    style={{marginRight:8}}
                  />
                  Höger vägg
                </label>
              </div>
              
              <div style={{marginBottom:8}}>
                <label style={{display:'flex', alignItems:'center', fontSize:14}}>
                  <input 
                    type="checkbox" 
                    checked={storageWallSelections.front}
                    onChange={e => setStorageWallSelections(prev => ({...prev, front: e.target.checked}))}
                    style={{marginRight:8}}
                  />
                  Framvägg (öppning mot montern)
                </label>
              </div>
            </div>
            
            <div style={{marginTop:8}}>
              <label style={{ fontWeight: 600, marginBottom: 4, display: 'block' }}>Ladda upp bild för förråd:</label>
              <input 
                type="file" 
                accept="image/*"
                onChange={e => {
                  const file = e.target.files?.[0];
                  if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                      setStorageUploadedImage(event.target?.result as string);
                    };
                    reader.readAsDataURL(file);
                  }
                }}
                style={{ fontSize: 12, marginBottom: 8, width: '100%' }}
              />
              {storageUploadedImage && (
                <div style={{ fontSize: 12, color: '#666' }}>✓ Förrådsbild uppladdad</div>
              )}
            </div>
          </div>
        )}
        
        {/* Diskinställningar för panelfärger */}
        {wallShape && wallShape !== '' && counters.length > 0 && (
          <div style={{marginTop:16}}>
            <label style={{ fontWeight: 600, marginRight: 8 }}>Diskars utseende:</label>
            
            <div style={{marginTop:8}}>
              <label style={{ fontWeight: 600, marginBottom: 4, display: 'block' }}>Färg på paneler (framsida + sidor):</label>
              <input
                type="color"
                value={counterPanelColor}
                onChange={(e) => setCounterPanelColor(e.target.value)}
                style={{ width: '100%', height: 30, border: '1px solid #ccc', borderRadius: 4 }}
              />
            </div>
          </div>
        )}

        {/* Bildkontroller för diskar - visas alltid när vi har diskar */}
        {counters.length > 0 && (
          <div style={{marginTop:16}}>
            <label style={{ fontWeight: 600, marginRight: 8 }}>Diskbilder:</label>
            
            <div style={{marginTop:8}}>
              <label style={{ fontWeight: 600, marginBottom: 4, display: 'block' }}>Eget tryck på framsida:</label>
              <input
                type="file"
                accept="image/*"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                      setCounterFrontImage(event.target?.result as string);
                    };
                    reader.readAsDataURL(file);
                  }
                }}
                style={{ width: '100%', padding: 4, border: '1px solid #ccc', borderRadius: 4 }}
              />
              {counterFrontImage && (
                <div style={{marginTop: 4}}>
                  <button
                    onClick={() => setCounterFrontImage(null)}
                    style={{
                      padding: '4px 8px',
                      fontSize: '12px',
                      backgroundColor: '#ff4444',
                      color: 'white',
                      border: 'none',
                      borderRadius: 4,
                      cursor: 'pointer'
                    }}
                  >
                    Ta bort bild
                  </button>
                </div>
              )}
            </div>
          </div>
        )}
        
        <div>
          <label style={{ fontWeight: 600, marginRight: 8 }}>Växter:</label>
          <div style={{fontSize:12, color:'#888', marginTop:4}}>
            🌱 <strong>Klicka på gröna rutor</strong> för att välja växttyp och placera.<br/>
            🔄 <strong>Klicka på placerad växt</strong> för att rotera den 90° åt gången.
          </div>
          
          {plants.length > 0 && (
            <div style={{fontSize:12, color:'#888', marginTop:8}}>
              Placerade växter: {plants.length}
              <button
                style={{marginLeft:12, padding:'4px 12px', fontWeight:600, background:'#ff4444', color:'#fff', border:'none', borderRadius:4, cursor:'pointer', fontSize:12}}
                onClick={() => setPlants([])}
              >Rensa alla</button>
            </div>
          )}
          
          {/* Växtkontroller */}
          {wallShape && wallShape !== '' && (
            <div style={{fontSize:12, color:'#888', marginTop:8}}>
              {plantMarkersVisible ? (
                <>
                  <div style={{marginBottom:8}}>
                    <label style={{display:'block', marginBottom:4, fontWeight:600}}>Välj växttyp:</label>
                    <select 
                      value={selectedPlantType} 
                      onChange={(e) => setSelectedPlantType(Number(e.target.value))}
                      style={{width:'100%', padding:8, borderRadius:4, border:'1px solid #ccc'}}
                    >
                      {PLANT_TYPES.map((opt, index) => (
                        <option key={index} value={index}>{opt.label}</option>
                      ))}
                    </select>
                  </div>
                  <span>Klicka på gröna rutor för att placera växter. </span>
                  <button
                    style={{padding:'6px 18px', fontWeight:600, background:'#1ec94c', color:'#fff', border:'none', borderRadius:6, cursor:'pointer', fontSize:15}}
                    onClick={() => setPlantMarkersVisible(false)}
                  >OK</button>
                </>
              ) : (
                <>
                  <button
                    style={{padding:'8px 16px', fontWeight:600, background:'#228B22', color:'#fff', border:'none', borderRadius:6, cursor:'pointer', fontSize:14, marginTop:8}}
                    onClick={() => setPlantMarkersVisible(true)}
                  >Lägg till växter</button>
                </>
              )}
            </div>
          )}
        </div>
        <div>
          <label style={{ fontWeight: 600, marginRight: 8 }}>Möbler:</label>
          <div style={{fontSize:12, color:'#888', marginTop:4}}>
            🪑 <strong>Klicka på blåa rutor</strong> för att välja möbeltyp och placera.<br/>
            🔄 <strong>Klicka på placerad möbel</strong> för att rotera den 90° åt gången.
          </div>
          
          {furniture.length > 0 && (
            <div style={{fontSize:12, color:'#888', marginTop:8}}>
              Placerade möbler: {furniture.length}
              <button
                style={{marginLeft:12, padding:'4px 12px', fontWeight:600, background:'#ff4444', color:'#fff', border:'none', borderRadius:4, cursor:'pointer', fontSize:12}}
                onClick={() => setFurniture([])}
              >Rensa alla</button>
            </div>
          )}
          
          {/* Möbelkontroller */}
          {wallShape && wallShape !== '' && (
            <div style={{fontSize:12, color:'#888', marginTop:8}}>
              {furnitureMarkersVisible ? (
                <>
                  <div style={{marginBottom:8}}>
                    <label style={{display:'block', marginBottom:4, fontWeight:600}}>Välj möbeltyp:</label>
                    <select 
                      value={selectedFurnitureType} 
                      onChange={(e) => setSelectedFurnitureType(Number(e.target.value))}
                      style={{width:'100%', padding:8, borderRadius:4, border:'1px solid #ccc'}}
                    >
                      {FURNITURE_TYPES.map((opt, index) => (
                        <option key={index} value={index}>{opt.label}</option>
                      ))}
                    </select>
                  </div>
                  <span>Klicka på blåa rutor för att placera möbler. </span>
                  <button
                    style={{padding:'6px 18px', fontWeight:600, background:'#1ec94c', color:'#fff', border:'none', borderRadius:6, cursor:'pointer', fontSize:15}}
                    onClick={() => setFurnitureMarkersVisible(false)}
                  >OK</button>
                </>
              ) : (
                <>
                  <button
                    style={{padding:'8px 16px', fontWeight:600, background:'#8B4513', color:'#fff', border:'none', borderRadius:6, cursor:'pointer', fontSize:14, marginTop:8}}
                    onClick={() => setFurnitureMarkersVisible(true)}
                  >Lägg till möbler</button>
                </>
              )}
            </div>
          )}
          
          {/* Visa placerade möbler */}
          {furniture.length > 0 && (
            <div style={{ fontSize: 12, color: '#888', marginTop: 8 }}>
              Placerade möbler: {furniture.length}
              <button
                style={{ marginLeft: 12, padding: '2px 8px', fontSize: 11, background: '#ff4444', color: '#fff', border: 'none', borderRadius: 3, cursor: 'pointer' }}
                onClick={() => setFurniture([])}
              >Rensa alla</button>
            </div>
          )}
        </div>
        {wallShape && wallShape !== '' && (
          <>
            
            {/* Nya funktioner */}
            <div style={{ marginTop: 16, padding: 12, backgroundColor: '#f5f5f5', borderRadius: 6 }}>
              <h3 style={{ margin: '0 0 12px 0', fontSize: 16, fontWeight: 600 }}>Väggdekorationer & Tillbehör</h3>
              
              <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: 8, marginBottom: 12 }}>
                {/* Hyllor på vägg */}
                <div>
                  <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: 13, fontWeight: 600 }}>
                    🗄️ Hyllor på vägg
                  </label>
                  <div style={{ fontSize: 12, color: '#666', marginBottom: 8 }}>
                    Klicka på väggarna för att placera hyllor (4 per kvm)
                  </div>
                  {wallShelves.length > 0 && (
                    <div style={{ fontSize: 12, color: '#888', marginBottom: 8 }}>
                      Placerade hyllor: {wallShelves.length}
                      <button
                        style={{ marginLeft: 12, padding: '2px 8px', fontSize: 11, background: '#ff4444', color: '#fff', border: 'none', borderRadius: 3, cursor: 'pointer' }}
                        onClick={() => setWallShelves([])}
                      >Rensa</button>
                    </div>
                  )}
                  {shelfMarkersVisible ? (
                    <button
                      style={{ padding: '4px 12px', fontSize: 12, background: '#1ec94c', color: '#fff', border: 'none', borderRadius: 4, cursor: 'pointer' }}
                      onClick={() => setShelfMarkersVisible(false)}
                    >OK</button>
                  ) : (
                    <button
                      style={{ padding: '4px 12px', fontSize: 12, background: '#007acc', color: '#fff', border: 'none', borderRadius: 4, cursor: 'pointer' }}
                      onClick={() => setShelfMarkersVisible(true)}
                    >Placera hyllor</button>
                  )}
                </div>
                
                {/* Extra el */}
                <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: 13 }}>
                  <input 
                    type="checkbox" 
                    checked={showExtraPower} 
                    onChange={(e) => setShowExtraPower(e.target.checked)}
                    style={{ marginRight: 6 }}
                  />
                  � Extra el-uttag (endast priseffekt)
                </label>
                
                {/* Högtalare på stativ */}
                <div>
                  <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: 13, fontWeight: 600 }}>
                    🔊 Högtalare på stativ
                  </label>
                  <div style={{ fontSize: 12, color: '#666', marginBottom: 8 }}>
                    Klicka på golvet för att placera högtalare (4 per ruta)
                  </div>
                  {speakers.length > 0 && (
                    <div style={{ fontSize: 12, color: '#888', marginBottom: 8 }}>
                      Placerade högtalare: {speakers.length}
                      <button
                        style={{ marginLeft: 12, padding: '2px 8px', fontSize: 11, background: '#ff4444', color: '#fff', border: 'none', borderRadius: 3, cursor: 'pointer' }}
                        onClick={() => setSpeakers([])}
                      >Rensa</button>
                    </div>
                  )}
                  <div style={{ marginBottom: 8 }}>
                    <label style={{ fontWeight: 600, marginRight: 8, fontSize: 13 }}>Storlek:</label>
                    <select 
                      value={speakerSize} 
                      onChange={e => setSpeakerSize(e.target.value as 'small' | 'medium' | 'large')}
                      style={{ fontSize: 12, padding: '2px 6px' }}
                    >
                      <option value="small">Liten</option>
                      <option value="medium">Medium</option>
                      <option value="large">Stor</option>
                    </select>
                  </div>
                  {speakerMarkersVisible ? (
                    <button
                      style={{ padding: '4px 12px', fontSize: 12, background: '#1ec94c', color: '#fff', border: 'none', borderRadius: 4, cursor: 'pointer' }}
                      onClick={() => setSpeakerMarkersVisible(false)}
                    >OK</button>
                  ) : (
                    <button
                      style={{ padding: '4px 12px', fontSize: 12, background: '#007acc', color: '#fff', border: 'none', borderRadius: 4, cursor: 'pointer' }}
                      onClick={() => setSpeakerMarkersVisible(true)}
                    >Placera högtalare</button>
                  )}
                </div>
              </div>
            </div>

            {/* Förrådstillbehör */}
            {storages.length > 0 && (
              <div style={{ marginTop: 12, padding: 12, backgroundColor: '#f0f8ff', borderRadius: 6 }}>
                <h3 style={{ margin: '0 0 12px 0', fontSize: 16, fontWeight: 600 }}>Förrådstillbehör</h3>
                
                <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: 13 }}>
                  <input 
                    type="checkbox" 
                    checked={showClothingRacks} 
                    onChange={(e) => setShowClothingRacks(e.target.checked)}
                    style={{ marginRight: 6 }}
                  />
                  👔 Klädhängare i förrå
                </label>
              </div>
            )}
          </>
        )}
  </>}

  {/* Prisberäkning */}
  <div id="price-summary" style={{ 
          position: 'sticky',
          bottom: 0,
          backgroundColor: '#fff',
          borderTop: '2px solid #007acc',
          padding: '16px',
          marginTop: '20px',
          boxShadow: '0 -4px 12px rgba(0,0,0,0.1)'
        }}>
          <h3 style={{ 
            margin: '0 0 12px 0', 
            fontSize: 18, 
            fontWeight: 700, 
            color: '#007acc' 
          }}>
            💰 Totalberäkning
          </h3>
          
          {floorIndex !== null ? (() => {
            const materialCost = calculatePrice();
            const laborCosts = calculateLaborCosts();
            const subtotal = materialCost + laborCosts.buildCost + laborCosts.demolitionCost + laborCosts.adminFee + laborCosts.consumables;
            const markup = Math.round(subtotal * 0.15); // 15% påslag
            const totalCost = subtotal + markup;
            
            return (
              <div>
                {/* Materialkostnad */}
                <div style={{ fontSize: 14, marginBottom: 4, display: 'flex', justifyContent: 'space-between' }}>
                  <span>Material & uthyrning:</span>
                  <span>{materialCost.toLocaleString('sv-SE')} kr</span>
                </div>
                
                {/* Byggkostnad */}
                <div style={{ fontSize: 14, marginBottom: 4, display: 'flex', justifyContent: 'space-between' }}>
                  <span>Uppsättning ({laborCosts.persons} pers × {laborCosts.buildHours}h):</span>
                  <span>{laborCosts.buildCost.toLocaleString('sv-SE')} kr</span>
                </div>
                
                {/* Rivningskostnad */}
                <div style={{ fontSize: 14, marginBottom: 4, display: 'flex', justifyContent: 'space-between' }}>
                  <span>Nedmontering ({laborCosts.persons} pers × {laborCosts.demolitionHours}h):</span>
                  <span>{laborCosts.demolitionCost.toLocaleString('sv-SE')} kr</span>
                </div>
                
                {/* Förbrukningsmaterial */}
                <div style={{ fontSize: 14, marginBottom: 4, display: 'flex', justifyContent: 'space-between' }}>
                  <span>Förbrukningsmaterial:</span>
                  <span>{laborCosts.consumables.toLocaleString('sv-SE')} kr</span>
                </div>
                
                {/* Byråavgift */}
                <div style={{ fontSize: 14, marginBottom: 4, display: 'flex', justifyContent: 'space-between' }}>
                  <span>Byråavgift:</span>
                  <span>{laborCosts.adminFee.toLocaleString('sv-SE')} kr</span>
                </div>
                
                {/* Subtotal */}
                <div style={{ fontSize: 14, marginBottom: 4, display: 'flex', justifyContent: 'space-between', borderTop: '1px solid #ddd', paddingTop: 4 }}>
                  <span><strong>Subtotal:</strong></span>
                  <span><strong>{subtotal.toLocaleString('sv-SE')} kr</strong></span>
                </div>
                
                {/* Påslag */}
                <div style={{ fontSize: 14, marginBottom: 8, display: 'flex', justifyContent: 'space-between' }}>
                  <span>Påslag (15%):</span>
                  <span>{markup.toLocaleString('sv-SE')} kr</span>
                </div>
                
                {/* Total */}
                <div style={{ 
                  fontSize: 20, 
                  fontWeight: 700, 
                  color: '#28a745',
                  marginBottom: '8px',
                  display: 'flex', 
                  justifyContent: 'space-between',
                  borderTop: '2px solid #28a745',
                  paddingTop: 8
                }}>
                  <span>TOTALT:</span>
                  <span>{totalCost.toLocaleString('sv-SE')} kr</span>
                </div>
                {/* Beställ-knapp */}
                <div style={{ marginTop: 10, marginBottom: 6 }}>
                  <button
                    onClick={async () => {
                      const pdf = new jsPDF('p', 'mm', 'a4');
                      const canvasEl = document.querySelector('canvas') as HTMLCanvasElement | null;
                      try {
                        if (canvasEl) {
                          // Prefer direct canvas export which is more reliable for WebGL content
                          try {
                            const imgData = canvasEl.toDataURL('image/png');
                            // Add the same view three times for now (top/front/far views require camera control)
                            pdf.addImage(imgData, 'PNG', 15, 15, 180, 100);
                            pdf.addPage();
                            pdf.addImage(imgData, 'PNG', 15, 15, 180, 100);
                            pdf.addPage();
                            pdf.addImage(imgData, 'PNG', 15, 15, 180, 100);
                            pdf.addPage();
                          } catch (e) {
                            // If canvas is tainted or toDataURL fails, fallback to html2canvas
                            const cFallback = await html2canvas(canvasEl as HTMLElement, { backgroundColor: null, scale: 1 });
                            const imgFb = cFallback.toDataURL('image/png');
                            pdf.addImage(imgFb, 'PNG', 15, 15, 180, 100);
                            pdf.addPage();
                            pdf.addImage(imgFb, 'PNG', 15, 15, 180, 100);
                            pdf.addPage();
                            pdf.addImage(imgFb, 'PNG', 15, 15, 180, 100);
                            pdf.addPage();
                          }
                        }

                        const priceEl = document.getElementById('price-summary');
                        if (priceEl) {
                          const cPrice = await html2canvas(priceEl as HTMLElement, { backgroundColor: '#ffffff', scale: 2 });
                          const imgP = cPrice.toDataURL('image/png');
                          pdf.addImage(imgP, 'PNG', 15, 15, 180, 100);
                        }

                        pdf.save('monter-bestallning.pdf');
                      } catch (err) {
                        console.error('Fel vid skapande av PDF', err);
                        alert('Kunde inte skapa PDF. Försök öppna appen i ett nytt fönster eller kontrollera att inga cross-origin-bilder används.');
                      }
                    }}
                    style={{
                      width: '100%',
                      padding: '10px 12px',
                      background: '#007acc',
                      color: '#fff',
                      border: 'none',
                      borderRadius: 6,
                      cursor: 'pointer',
                      fontWeight: 700,
                      fontSize: 14
                    }}
                  >
                    Beställ (PDF)
                  </button>
                </div>
              </div>
            );
          })() : (
            <div style={{ fontSize: 18, color: '#666' }}>Välj golvstorlek för att se pris</div>
          )}
          
          <div style={{ 
            fontSize: 11, 
            color: '#666',
            lineHeight: '1.3',
            marginTop: 8
          }}>
            Pris exklusive moms. Frakt och eventuella hotellkostnader tillkommer.
            <br />
            Montern: {floorIndex !== null ? `${calculateLaborCosts().area}m²` : '-'}
          </div>
        </div>
      </div>
      
      {/* Mässmiljö-knapp i högra hörnet */}
      <button
        style={{
          position: 'fixed',
          top: '20px',
          right: '20px',
          padding: '8px 16px',
          fontSize: '12px',
          background: showExhibitionHall ? '#28a745' : '#6c757d',
          color: '#fff',
          border: 'none',
          borderRadius: '6px',
          cursor: 'pointer',
          zIndex: 1000,
          fontWeight: '500',
          boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
        }}
        onClick={() => setShowExhibitionHall(!showExhibitionHall)}
      >
        {showExhibitionHall ? '🏢 Dölj mässhall' : '🏢 Visa mässhall'}
      </button>
      
      {/* 3D-scen */}
      <div style={{ marginLeft: 300, width: 'calc(100vw - 300px)', height: '100vh' }}>
        {floorIndex !== null && (() => {
          // Hjälpfunktion för att få rätt golvdimensioner
          const getFloorDimensions = () => {
            const floorConfig = FLOOR_SIZES[floorIndex];
            if (floorConfig?.custom) {
              return { width: customFloorWidth, depth: customFloorDepth };
            }
            return { width: floorConfig.width, depth: floorConfig.depth };
          };
          
          const floorDimensions = getFloorDimensions();
          
          return (
          <Canvas camera={{ position: [0, 2, 6], fov: 50 }} shadows>
            <CaptureHelper ref={captureRef} />
            {/* Visa golvplatta */}
            <Grid args={[20, 20]} cellColor="#bbb" sectionColor="#888" fadeDistance={20} position={[0, 0, 0]} />
            <ambientLight intensity={0.8} />
            <directionalLight position={[5, 10, 5]} intensity={0.5} />
            
            {/* Mässhallsmiljö - visas bara när showExhibitionHall är true */}
            {showExhibitionHall && (
              <>
                {/* Stort tunt golv under montern */}
                <mesh position={[0, -0.02, 0]} receiveShadow>
                  <boxGeometry args={[100, 0.04, 100]} />
                  <meshStandardMaterial 
                    color="#f0f0f0" 
                    roughness={0.8}
                    metalness={0.0}
                  />
                </mesh>
                
                {/* Väggar runt golvet */}
                {/* Fram-vägg */}
                <mesh position={[0, 2, 50]} castShadow>
                  <boxGeometry args={[100, 4, 0.2]} />
                  <meshStandardMaterial color="#e0e0e0" roughness={0.7} />
                </mesh>
                
                {/* Bak-vägg */}
                <mesh position={[0, 2, -50]} castShadow>
                  <boxGeometry args={[100, 4, 0.2]} />
                  <meshStandardMaterial color="#e0e0e0" roughness={0.7} />
                </mesh>
                
                {/* Vänster vägg */}
                <mesh position={[-50, 2, 0]} castShadow>
                  <boxGeometry args={[0.2, 4, 100]} />
                  <meshStandardMaterial color="#e0e0e0" roughness={0.7} />
                </mesh>
                
                {/* Höger vägg */}
                <mesh position={[50, 2, 0]} castShadow>
                  <boxGeometry args={[0.2, 4, 100]} />
                  <meshStandardMaterial color="#e0e0e0" roughness={0.7} />
                </mesh>
                
                {/* Ljusa monterplatser */}
                <mesh position={[-30, 0.01, -35]} receiveShadow>
                  <boxGeometry args={[8, 0.02, 6]} />
                  <meshStandardMaterial color="#ffffff" roughness={0.3} />
                </mesh>
                <mesh position={[-10, 0.01, -35]} receiveShadow>
                  <boxGeometry args={[6, 0.02, 6]} />
                  <meshStandardMaterial color="#ffffff" roughness={0.3} />
                </mesh>
                <mesh position={[10, 0.01, -35]} receiveShadow>
                  <boxGeometry args={[6, 0.02, 6]} />
                  <meshStandardMaterial color="#ffffff" roughness={0.3} />
                </mesh>
                <mesh position={[30, 0.01, -35]} receiveShadow>
                  <boxGeometry args={[8, 0.02, 6]} />
                  <meshStandardMaterial color="#ffffff" roughness={0.3} />
                </mesh>
              </>
            )}
            
            <Floor 
              width={floorDimensions.width} 
              depth={floorDimensions.depth} 
            />
            
            {carpetIndex !== 0 && CARPET_COLORS[carpetIndex].color && (
              <Carpet width={floorDimensions.width} depth={floorDimensions.depth} color={CARPET_COLORS[carpetIndex].color as string} />
            )}
            
            {/* Disk placering markörer - visa gröna rutor på halvmeter precision */}
            {wallShape && wallShape !== '' && counterMarkersVisible && (() => {
              const floor = floorDimensions;
              const markers = [];
              
              // Skapa markörer för varje halvmeter (finare precision för diskar)
              for (let x = 0; x < floor.width * 2; x++) {
                for (let z = 0; z < floor.depth * 2; z++) {
                  const posX = x * 0.5 - floor.width/2 + 0.25;
                  const posZ = z * 0.5 - floor.depth/2 + 0.25;
                  
                  markers.push(
                    <mesh
                      key={`counter-marker-${x}-${z}`}
                      position={[posX, 0.13, posZ]}
                      rotation={[-Math.PI / 2, 0, 0]}
                      onClick={() => {
                        // Skapa disk direkt med vald typ
                        const counterConfig = COUNTER_TYPES[selectedCounterType];
                        const floor = FLOOR_SIZES[floorIndex];
                        
                        // Kontrollera att disken passar inom monterområdet
                        let canPlace = true;
                        if (counterConfig.type === 'L' || counterConfig.type === 'L-mirrored') {
                          // L-formad disk: kontrollera både delar
                          const maxX = floor.width / 2;
                          const minX = -floor.width / 2;
                          const maxZ = floor.depth / 2;
                          const minZ = -floor.depth / 2;
                          
                          // Kontrollera första delen (1,5m x 0,5m)
                          if (posX + 0.75 > maxX || posX - 0.75 < minX || 
                              posZ + 0.25 > maxZ || posZ - 0.25 < minZ) {
                            canPlace = false;
                          }
                          
                          // Kontrollera andra delen beroende på typ
                          if (counterConfig.type === 'L') {
                            // Vanlig L: andra delen åt höger
                            if (posX + 1.25 > maxX || posZ + 0.75 > maxZ || posZ - 0.75 < minZ) {
                              canPlace = false;
                            }
                          } else {
                            // Spegelvänd L: andra delen åt vänster
                            if (posX - 1.25 < minX || posZ + 0.75 > maxZ || posZ - 0.75 < minZ) {
                              canPlace = false;
                            }
                          }
                        } else {
                          // Vanlig rak disk
                          const maxX = floor.width / 2 - counterConfig.width / 2;
                          const minX = -floor.width / 2 + counterConfig.width / 2;
                          const maxZ = floor.depth / 2 - counterConfig.depth / 2;
                          const minZ = -floor.depth / 2 + counterConfig.depth / 2;
                          
                          if (posX > maxX || posX < minX || posZ > maxZ || posZ < minZ) {
                            canPlace = false;
                          }
                        }
                        
                        if (canPlace && selectedCounterType > 0) {
                          setCounters(prev => [...prev, {
                            id: nextCounterId,
                            type: selectedCounterType,
                            position: {x: posX, z: posZ},
                            rotation: 0
                          }]);
                          setNextCounterId(prev => prev + 1);
                        }
                      }}
                    >
                      <planeGeometry args={[0.4, 0.4]} />
                      <meshBasicMaterial color="#1ec94c" opacity={0.3} transparent />
                    </mesh>
                  );
                }
              }
              
              return <>{markers}</>;
            })()}

            {/* Förråd placering markörer - visa blå rutor bara i framre hörnen */}
            {wallShape && wallShape !== '' && storageMarkersVisible && (() => {
              const floor = floorDimensions;
              const storageMarkers: React.ReactElement[] = [];
              
              // Skapa markörer endast i de två framre hörnen
              const frontCorners = [
                {x: 0, z: 0}, // Hörn vänster fram
                {x: floor.width - 1, z: 0}, // Hörn höger fram  
              ];
              
              frontCorners.forEach((corner) => {
                const posX = corner.x - floor.width/2 + 0.5;
                const posZ = corner.z - floor.depth/2 + 0.5;
                
                storageMarkers.push(
                  <mesh
                    key={`storage-marker-${corner.x}-${corner.z}`}
                    position={[posX, 0.14, posZ]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    onClick={() => {
                      // Skapa förråd direkt med vald typ
                      const floor = FLOOR_SIZES[floorIndex];
                      const storageConfig = STORAGE_TYPES[selectedStorageType];
                      
                      // Justera position så förrådet håller sig inom monterområdet
                      let adjustedX = posX;
                      let adjustedZ = posZ;
                      
                      // Kontrollera och justera X-position
                      const maxX = floor.width / 2 - storageConfig.width / 2;
                      const minX = -floor.width / 2 + storageConfig.width / 2;
                      if (adjustedX > maxX) adjustedX = maxX;
                      if (adjustedX < minX) adjustedX = minX;
                      
                      // Kontrollera och justera Z-position
                      const maxZ = floor.depth / 2 - storageConfig.depth / 2;
                      const minZ = -floor.depth / 2 + storageConfig.depth / 2;
                      if (adjustedZ > maxZ) adjustedZ = maxZ;
                      if (adjustedZ < minZ) adjustedZ = minZ;
                      
                      setStorages(prev => [...prev, {
                        id: nextStorageId,
                        type: selectedStorageType,
                        position: {x: adjustedX, z: adjustedZ},
                        rotation: 0
                      }]);
                      setNextStorageId(prev => prev + 1);
                    }}
                  >
                    <planeGeometry args={[0.8, 0.8]} />
                    <meshBasicMaterial color="#4169E1" opacity={0.3} transparent />
                  </mesh>
                );
              });
              
              return <>{storageMarkers}</>;
            })()}

            {/* Växt placering markörer - visa gröna rutor på hela golvet */}
            {wallShape && wallShape !== '' && plantMarkersVisible && (() => {
              const floor = floorDimensions;
              const plantMarkers = [];
              
              // Skapa markörer för varje golvplatta
              for (let x = 0; x < floor.width; x++) {
                for (let z = 0; z < floor.depth; z++) {
                  const posX = x - floor.width/2 + 0.5;
                  const posZ = z - floor.depth/2 + 0.5;
                  
                  // Kontrollera att positionen inte kolliderar med förråd, diskar eller TVs
                  const hasCollision = storages.some(storage => {
                    const storageConfig = STORAGE_TYPES[storage.type];
                    const isRotated = storage.rotation === 90 || storage.rotation === 270;
                    const effectiveWidth = isRotated ? storageConfig.depth : storageConfig.width;
                    const effectiveDepth = isRotated ? storageConfig.width : storageConfig.depth;
                    
                    return Math.abs(posX - storage.position.x) < effectiveWidth/2 + 0.3 &&
                           Math.abs(posZ - storage.position.z) < effectiveDepth/2 + 0.3;
                  }) || counters.some(counter => {
                    const counterConfig = COUNTER_TYPES[counter.type];
                    if (counterConfig.type === 'L') {
                      // L-formad disk kollision
                      return Math.abs(posX - counter.position.x) < 1.0 &&
                             Math.abs(posZ - counter.position.z) < 1.0;
                    } else if (counterConfig.type === 'L-mirrored') {
                      // Spegelvänd L-formad disk kollision
                      return Math.abs(posX - counter.position.x) < 1.0 &&
                             Math.abs(posZ - counter.position.z) < 1.0;
                    } else {
                      return Math.abs(posX - counter.position.x) < counterConfig.width/2 + 0.3 &&
                             Math.abs(posZ - counter.position.z) < counterConfig.depth/2 + 0.3;
                    }
                  });
                  
                  if (!hasCollision) {
                    plantMarkers.push(
                      <mesh
                        key={`plant-marker-${x}-${z}`}
                        position={[posX, 0.15, posZ]}
                        rotation={[-Math.PI / 2, 0, 0]}
                        onClick={() => {
                          // Skapa växt direkt med vald typ
                          setPlants(prev => [...prev, {
                            id: nextPlantId,
                            type: selectedPlantType,
                            position: {x: posX, z: posZ},
                            rotation: 0
                          }]);
                          setNextPlantId(prev => prev + 1);
                        }}
                      >
                        <planeGeometry args={[0.6, 0.6]} />
                        <meshBasicMaterial color="#32CD32" opacity={0.4} transparent />
                      </mesh>
                    );
                  }
                }
              }
              
              return <>{plantMarkers}</>;
            })()}

            {/* Möbel placering markörer - visa blåa rutor på hela golvet */}
            {wallShape && wallShape !== '' && furnitureMarkersVisible && (() => {
              const floor = floorDimensions;
              const furnitureMarkers = [];
              
              // Skapa markörer för varje halv-meter (finare precision för möbler)
              for (let x = 0; x < floor.width * 2; x++) {
                for (let z = 0; z < floor.depth * 2; z++) {
                  const posX = x * 0.5 - floor.width/2 + 0.25;
                  const posZ = z * 0.5 - floor.depth/2 + 0.25;
                  
                  // Kontrollera att positionen inte kolliderar med förråd, diskar eller TVs
                  const hasCollision = storages.some(storage => {
                    const storageConfig = STORAGE_TYPES[storage.type];
                    const isRotated = storage.rotation === 90 || storage.rotation === 270;
                    const effectiveWidth = isRotated ? storageConfig.depth : storageConfig.width;
                    const effectiveDepth = isRotated ? storageConfig.width : storageConfig.depth;
                    
                    return Math.abs(posX - storage.position.x) < effectiveWidth/2 + 0.2 &&
                           Math.abs(posZ - storage.position.z) < effectiveDepth/2 + 0.2;
                  }) || counters.some(counter => {
                    const counterConfig = COUNTER_TYPES[counter.type];
                    if (counterConfig.type === 'L') {
                      // L-formad disk kollision
                      return Math.abs(posX - counter.position.x) < 0.8 &&
                             Math.abs(posZ - counter.position.z) < 0.8;
                    } else if (counterConfig.type === 'L-mirrored') {
                      // Spegelvänd L-formad disk kollision
                      return Math.abs(posX - counter.position.x) < 0.8 &&
                             Math.abs(posZ - counter.position.z) < 0.8;
                    } else {
                      return Math.abs(posX - counter.position.x) < counterConfig.width/2 + 0.2 &&
                             Math.abs(posZ - counter.position.z) < counterConfig.depth/2 + 0.2;
                    }
                  });
                  
                  if (!hasCollision) {
                    furnitureMarkers.push(
                      <mesh
                        key={`furniture-marker-${x}-${z}`}
                        position={[posX, 0.15, posZ]}
                        rotation={[-Math.PI / 2, 0, 0]}
                        onClick={() => {
                          // Skapa möbel direkt med vald typ
                          setFurniture(prev => [...prev, {
                            id: nextFurnitureId,
                            type: selectedFurnitureType,
                            position: {x: posX, z: posZ},
                            rotation: 0
                          }]);
                          setNextFurnitureId(prev => prev + 1);
                        }}
                      >
                        <planeGeometry args={[0.4, 0.4]} />
                        <meshBasicMaterial color="#4169E1" opacity={0.4} transparent />
                      </mesh>
                    );
                  }
                }
              }
              
              return <>{furnitureMarkers}</>;
            })()}

            {/* Väggar centrerade */}
            {wallShape && wallShape !== '' && (() => {
              const floor = floorDimensions;
              let wallColor = '#cccccc';
              let wallMaterial = 'standard';
              if (graphic === 'hyr') {
                wallColor = '#fff';
                wallMaterial = 'standard';
              } else if (graphic === 'vepa') {
                wallColor = '#d3d3d3'; // ljusgrå
                wallMaterial = 'standard';
              } else if (graphic === 'forex') {
                wallColor = '#d3d3d3'; // ljusgrå
                wallMaterial = 'standard';
              } else {
                wallColor = '#888'; // grå när inget val är gjort
                wallMaterial = 'standard';
              }
              const thickness = 0.065;
              const height = wallHeight;
              // const offset = 0.065; // ej använd
              const makeWallSections = (start: [number, number, number], dir: [number, number, number], length: number, rotY: number) => {
                const sections = [];
                const n = Math.ceil(length);
                const actualWallColor = wallColor;
                const floorThickness = 0.12;
                for (let i = 0; i < n; i++) {
                  let segLength = 1;
                  if (i === n - 1) {
                    segLength = length - (n - 1);
                  }
                  const y = height/2 + floorThickness/2;
                  const pos: [number, number, number] = [
                    start[0] + dir[0] * (i + segLength/2),
                    y,
                    start[2] + dir[2] * (i + segLength/2)
                  ];
                  const Material = wallMaterial === 'basic' ? 'meshBasicMaterial' : 'meshStandardMaterial';
                  const thinWall = thickness / 2;
                  
                  if (rotY === 0) {
                    // Bakvägg: Insidan (mot montern) är +Z, utsidan är -Z
                    // Färgad sida (insidan) - mot montern
                    
                    sections.push(
                      <mesh key={rotY + '-' + i + '-inside'} position={[pos[0], pos[1], pos[2] + thinWall/2]} rotation={[0, 0, 0]}>
                        <boxGeometry args={[segLength, height, thinWall]} />
                        {Material === 'meshBasicMaterial' ? (
                          <meshBasicMaterial color={actualWallColor} />
                        ) : (
                          <meshStandardMaterial color={actualWallColor} />
                        )}
                      </mesh>
                    );
                    // Vit sida (utsidan)
                    sections.push(
                      <mesh key={rotY + '-' + i + '-outside'} position={[pos[0], pos[1], pos[2] - thinWall/2]} rotation={[0, 0, 0]}>
                        <boxGeometry args={[segLength, height, thinWall]} />
                        {Material === 'meshBasicMaterial' ? (
                          <meshBasicMaterial color="#fff" />
                        ) : (
                          <meshStandardMaterial color="#fff" />
                        )}
                      </mesh>
                    );
                  } else {
                    // Sidoväggar: För vänstervägg är insidan +X, för högervägg är insidan -X
                    // Vi behöver veta vilken vägg det är baserat på startposition
                    const isLeftWall = start[0] < 0; // Vänstervägg har negativ X-startposition
                    
                    if (isLeftWall) {
                      // Vänstervägg: insidan är +X (mot mitten av montern)
                      sections.push(
                        <mesh key={rotY + '-' + i + '-inside'} position={[pos[0] + thinWall/2, pos[1], pos[2]]} rotation={[0, Math.PI/2, 0]}>
                          <boxGeometry args={[segLength, height, thinWall]} />
                          {Material === 'meshBasicMaterial' ? (
                            <meshBasicMaterial color={actualWallColor} />
                          ) : (
                            <meshStandardMaterial color={actualWallColor} />
                          )}
                        </mesh>
                      );
                      // Utsidan är -X
                      sections.push(
                        <mesh key={rotY + '-' + i + '-outside'} position={[pos[0] - thinWall/2, pos[1], pos[2]]} rotation={[0, Math.PI/2, 0]}>
                          <boxGeometry args={[segLength, height, thinWall]} />
                          {Material === 'meshBasicMaterial' ? (
                            <meshBasicMaterial color="#fff" />
                          ) : (
                            <meshStandardMaterial color="#fff" />
                          )}
                        </mesh>
                      );
                    } else {
                      // Högervägg: insidan är -X (mot mitten av montern)
                      sections.push(
                        <mesh key={rotY + '-' + i + '-inside'} position={[pos[0] - thinWall/2, pos[1], pos[2]]} rotation={[0, Math.PI/2, 0]}>
                          <boxGeometry args={[segLength, height, thinWall]} />
                          {Material === 'meshBasicMaterial' ? (
                            <meshBasicMaterial color={actualWallColor} />
                          ) : (
                            <meshStandardMaterial color={actualWallColor} />
                          )}
                        </mesh>
                      );
                      // Utsidan är +X
                      sections.push(
                        <mesh key={rotY + '-' + i + '-outside'} position={[pos[0] + thinWall/2, pos[1], pos[2]]} rotation={[0, Math.PI/2, 0]}>
                          <boxGeometry args={[segLength, height, thinWall]} />
                          {Material === 'meshBasicMaterial' ? (
                            <meshBasicMaterial color="#fff" />
                          ) : (
                            <meshStandardMaterial color="#fff" />
                          )}
                        </mesh>
                      );
                    }
                  }
                }
                return sections;
              };
              // Dynamiskt antal platser per vägg baserat på väggens längd
              const y = height/2 + 0.06;
              const boxSize = 0.5;
              const gap = 0.35;
              // Funktion för att räkna ut hur många platser som får plats på en vägg
              const getSpots = (length: number) => {
                const n = Math.floor((length + gap) / (boxSize + gap));
                return Math.max(1, n);
              };
              // Antal platser per vägg
              const spotsBack = getSpots(floor.width);
              const spotsLeft = getSpots(floor.depth);
              const spotsRight = getSpots(floor.depth);

              // StartX för varje vägg
              const calcWallStartX = (spots: number) => {
                const totalWidth = spots * boxSize + (spots - 1) * gap;
                return -totalWidth / 2 + boxSize / 2;
              };

              // Hjälpfunktion för att rendera TV på en vägg, endast om väggen finns
              const wallExists = (wall: 'back'|'left'|'right') => {
                if (wallShape === 'straight') return wall === 'back';
                if (wallShape === 'l') return wall === 'back' || wall === 'left';
                if (wallShape === 'u') return true;
                return false;
              };

              const renderTVs = (wall: 'back'|'left'|'right') => {
                if (!wallExists(wall)) return null;
                let spots = wall === 'back' ? spotsBack : wall === 'left' ? spotsLeft : spotsRight;
                let wallStartX = calcWallStartX(spots);
                
                return tvs
                  .filter(tv => tv.wall === wall)
                  .map((tv) => {
                    const tvConfig = TV_SIZES[tv.size];
                    const tvLabel = tvConfig.label === 'Ingen' ? '' : `TV${tvConfig.label.replace(/"/g, '')}`;
                    
                    let position: [number, number, number];
                    let rotation: [number, number, number] = [0, 0, 0];
                    if (wall === 'back') {
                      position = [wallStartX + tv.position * (boxSize + gap), y, -(floor.depth/2) + 0.065 + 0.025];
                    } else if (wall === 'left') {
                      position = [-(floor.width/2) + 0.065 + 0.025, y, wallStartX + tv.position * (boxSize + gap)];
                      rotation = [0, Math.PI/2, 0];
                    } else {
                      position = [(floor.width/2) - 0.065 - 0.025, y, wallStartX + tv.position * (boxSize + gap)];
                      rotation = [0, -Math.PI/2, 0];
                    }
                    
                    return (
                      <group key={tv.id}>
                        <mesh
                          position={position}
                          rotation={rotation}
                          onDoubleClick={() => {
                            setTvs(prev => prev.map(t => 
                              t.id === tv.id 
                                ? {...t, orientation: t.orientation === 'landscape' ? 'portrait' : 'landscape'}
                                : t
                            ));
                          }}
                          onContextMenu={(e) => {
                            e.stopPropagation();
                            // Högerklick för att ta bort TV
                            setTvs(prev => prev.filter(t => t.id !== tv.id));
                          }}
                        >
                          <boxGeometry args={tv.orientation === 'portrait' ? [tvConfig.height, tvConfig.width, 0.08] : [tvConfig.width, tvConfig.height, 0.08]} />
                          <meshStandardMaterial color="#222" />
                        </mesh>
                        {tvLabel && (
                          <Text
                            position={[
                              wall === 'left' ? position[0] + 0.05 : wall === 'right' ? position[0] - 0.05 : position[0], 
                              position[1], 
                              wall === 'back' ? position[2] + 0.05 : position[2]
                            ]}
                            rotation={wall === 'back' ? [0, 0, 0] : wall === 'left' ? [0, Math.PI/2, 0] : [0, -Math.PI/2, 0]}
                            fontSize={0.08}
                            color="white"
                            anchorX="center"
                            anchorY="middle"
                          >
                            {tvLabel}
                          </Text>
                        )}
                      </group>
                    );
                  })
              };

              const renderLights = (wall: 'back'|'left'|'right') => {
                if (!wallExists(wall)) return null;
                const wallLength = wall === 'back' ? floor.width : floor.depth;
                return Array.from({length: Math.floor(wallLength)}).map((_, i) => {
                  let rotation: [number, number, number] = [0, 0, 0];
                  let position: [number, number, number];
                  
                  const lightCenter = -wallLength/2 + (i + 0.5);
                  
                  if (wall === 'back') {
                    // Inne i montern - bakre vägg (15cm in från vägg), helt ovanpå väggen
                    position = [lightCenter, wallHeight + 0.07, -(floor.depth/2) + 0.12];
                  } else if (wall === 'left') {
                    // Inne i montern - vänster vägg (15cm in från vägg), helt ovanpå väggen
                    position = [-(floor.width/2) + 0.12, wallHeight + 0.07, lightCenter];
                    rotation = [0, Math.PI/2, 0];
                  } else {
                    // Inne i montern - höger vägg (15cm in från vägg), helt ovanpå väggen
                    position = [(floor.width/2) - 0.12, wallHeight + 0.07, lightCenter];
                    rotation = [0, -Math.PI/2, 0];
                  }
                  
                  // Kontrollera om denna lampa kolliderar med något förråd
                  const hasCollisionWithStorage = storages.some(storage => {
                    const storageConfig = STORAGE_TYPES[storage.type];
                    const isRotated = storage.rotation === 90 || storage.rotation === 270;
                    const effectiveWidth = isRotated ? storageConfig.depth : storageConfig.width;
                    const effectiveDepth = isRotated ? storageConfig.width : storageConfig.depth;
                    
                    // Kontrollera om lampan är nära förrådets position
                    const storageMinX = storage.position.x - effectiveWidth/2;
                    const storageMaxX = storage.position.x + effectiveWidth/2;
                    const storageMinZ = storage.position.z - effectiveDepth/2;
                    const storageMaxZ = storage.position.z + effectiveDepth/2;
                    
                    // Utöka området med lite marginal för att undvika lampor nära förrådet
                    const margin = 0.3;
                    
                    return position[0] >= storageMinX - margin && 
                           position[0] <= storageMaxX + margin &&
                           position[2] >= storageMinZ - margin && 
                           position[2] <= storageMaxZ + margin;
                  });
                  
                  // Visa bara lampan om den inte kolliderar med förråd
                  if (hasCollisionWithStorage) return null;
                  
                  return (
                    <group key={`light-${wall}-${i}`}>
                      {/* Lampram - ljusare grå färg */}
                      <mesh position={position} rotation={rotation}>
                        <boxGeometry args={[0.06, 0.015, 0.3]} />
                        <meshStandardMaterial color="#999" />
                      </mesh>
                      
                      {/* Centrerad LED-strip - tydlig vit i mitten som i din bild */}
                      <mesh 
                        position={[
                          position[0], 
                          position[1] - 0.005, 
                          position[2]
                        ]} 
                        rotation={rotation}
                      >
                        <boxGeometry args={[0.05, 0.008, 0.25]} />
                        <meshStandardMaterial 
                          color="#ffffff" 
                          emissive="#ffffff" 
                          emissiveIntensity={1.2}
                        />
                      </mesh>
                      
                      {/* Jämn bred belysning utan ringar */}
                      <spotLight
                        position={[position[0], position[1] - 0.01, position[2]]}
                        target-position={[position[0], 0, position[2]]}
                        intensity={0.3}
                        angle={Math.PI / 2.5}
                        penumbra={0.9}
                        color="#e8f4fd"
                        distance={4}
                        decay={1}
                      />
                      
                      {/* Mjuk ambient belysning för jämn täckning */}
                      <pointLight
                        position={[position[0], position[1] - 0.4, position[2]]}
                        intensity={0.25}
                        color="#e8f4fd"
                        distance={3}
                        decay={0.3}
                      />
                      
                      {/* Extra diffust ljus för att fylla skuggor */}
                      <pointLight
                        position={[position[0], 0.5, position[2]]}
                        intensity={0.15}
                        color="#e8f4fd"
                        distance={3.5}
                        decay={0.2}
                      />
                    </group>
                  );
                });
              };

              // Hjälpfunktion för att rendera markers på en vägg, endast om väggen finns och markers är synliga och man valt en riktig TV
              const renderMarkers = (wall: 'back'|'left'|'right') => {
                if (!wallExists(wall) || !tvMarkersVisible) return null;
                let spots = wall === 'back' ? spotsBack : wall === 'left' ? spotsLeft : spotsRight;
                let wallStartX = calcWallStartX(spots);
                return Array.from({length: spots}).map((_, i) => {
                  const isPlaced = tvs.some(tv => tv.wall === wall && tv.position === i);
                  let position: [number, number, number];
                  let rotation: [number, number, number] = [0, 0, 0];
                  if (wall === 'back') {
                    position = [wallStartX + i * (boxSize + gap), y, -(floor.depth/2) + 0.065 + 0.015];
                  } else if (wall === 'left') {
                    position = [-(floor.width/2) + 0.065 + 0.015, y, wallStartX + i * (boxSize + gap)];
                    rotation = [0, Math.PI/2, 0];
                  } else {
                    position = [(floor.width/2) - 0.065 - 0.015, y, wallStartX + i * (boxSize + gap)];
                    rotation = [0, -Math.PI/2, 0];
                  }
                  return (
                    <mesh
                      key={wall + '-' + i}
                      position={position}
                      rotation={rotation}
                      onClick={() => {
                        if (isPlaced) return;
                        // Skapa TV direkt med vald storlek
                        setTvs(prev => [...prev, {
                          id: nextTvId,
                          size: selectedTvSize,
                          wall: wall,
                          position: i,
                          orientation: 'landscape'
                        }]);
                        setNextTvId(prev => prev + 1);
                      }}
                    >
                      <planeGeometry args={[boxSize, boxSize]} />
                      <meshBasicMaterial color={'#1ec94c'} opacity={isPlaced ? 0.35 : 0.18} transparent />
                      <Edges scale={1.01} color={'#1ec94c'} />
                    </mesh>
                  );
                });
              };
              // Rendera väggar enligt vald väggform, men markers/TV på alla väggar
              let back = null, left = null, right = null;
              if (wallShape === 'straight') {
                back = makeWallSections(
                  [-(floor.width/2), height/2 + 0.06, -(floor.depth/2)],
                  [1, 0, 0],
                  floor.width,
                  0
                );
              } else if (wallShape === 'l') {
                back = makeWallSections(
                  [-(floor.width/2), height/2 + 0.06, -(floor.depth/2)],
                  [1, 0, 0],
                  floor.width,
                  0
                );
                left = makeWallSections(
                  [-(floor.width/2), height/2 + 0.06, -(floor.depth/2)],
                  [0, 0, 1],
                  floor.depth,
                  Math.PI/2
                );
              } else if (wallShape === 'u') {
                back = makeWallSections(
                  [-(floor.width/2), height/2 + 0.06, -(floor.depth/2)],
                  [1, 0, 0],
                  floor.width,
                  0
                );
                left = makeWallSections(
                  [-(floor.width/2), height/2 + 0.06, -(floor.depth/2)],
                  [0, 0, 1],
                  floor.depth,
                  Math.PI/2
                );
                right = makeWallSections(
                  [(floor.width/2), height/2 + 0.06, -(floor.depth/2)],
                  [0, 0, 1],
                  floor.depth,
                  Math.PI/2
                );
              }
              return <>
                {back}
                {left}
                {right}
                {/* Bildlager för bakvägg - ett stort plan över hela väggen */}
                {graphic === 'vepa' && uploadedImage && floorIndex !== null && (
                  <ImageOverlay 
                    imageUrl={uploadedImage} 
                    wallLength={FLOOR_SIZES[floorIndex].width}
                    wallHeight={wallHeight}
                    position={[0, wallHeight/2 + 0.06, -(FLOOR_SIZES[floorIndex].depth/2) + 0.04]}
                  />
                )}
                {/* Bildlager för vänster vägg - visas i L-form och U-form */}
                {graphic === 'vepa' && uploadedImageLeft && floorIndex !== null && (wallShape === 'l' || wallShape === 'u') && (
                  <mesh 
                    position={[-(FLOOR_SIZES[floorIndex].width/2) + 0.04, wallHeight/2 + 0.06, 0]} 
                    rotation={[0, Math.PI/2, 0]}
                  >
                    <planeGeometry args={[FLOOR_SIZES[floorIndex].depth, wallHeight]} />
                    <meshStandardMaterial 
                      map={(() => {
                        const texture = new THREE.TextureLoader().load(uploadedImageLeft);
                        texture.wrapS = THREE.ClampToEdgeWrapping;
                        texture.wrapT = THREE.ClampToEdgeWrapping;
                        texture.flipY = true;
                        return texture;
                      })()} 
                      side={THREE.DoubleSide} 
                    />
                  </mesh>
                )}
                {/* Bildlager för höger vägg - visas endast i U-form */}
                {graphic === 'vepa' && uploadedImageRight && floorIndex !== null && wallShape === 'u' && (
                  <mesh 
                    position={[(FLOOR_SIZES[floorIndex].width/2) - 0.04, wallHeight/2 + 0.06, 0]} 
                    rotation={[0, -Math.PI/2, 0]}
                  >
                    <planeGeometry args={[FLOOR_SIZES[floorIndex].depth, wallHeight]} />
                    <meshStandardMaterial 
                      map={(() => {
                        const texture = new THREE.TextureLoader().load(uploadedImageRight);
                        texture.wrapS = THREE.ClampToEdgeWrapping;
                        texture.wrapT = THREE.ClampToEdgeWrapping;
                        texture.flipY = true;
                        return texture;
                      })()} 
                      side={THREE.DoubleSide} 
                    />
                  </mesh>
                )}
                
                {/* FOREX bildlager med silvriga lister varje meter */}
                {/* Forex bakvägg */}
                {graphic === 'forex' && forexImageBack && floorIndex !== null && (
                  <ForexImageOverlay 
                    imageUrl={forexImageBack} 
                    wallLength={FLOOR_SIZES[floorIndex].width}
                    wallHeight={wallHeight}
                    position={[0, wallHeight/2 + 0.06, -(FLOOR_SIZES[floorIndex].depth/2) + 0.04]}
                  />
                )}
                {/* Forex vänster vägg */}
                {graphic === 'forex' && forexImageLeft && floorIndex !== null && (wallShape === 'l' || wallShape === 'u') && (
                  <ForexImageOverlay 
                    imageUrl={forexImageLeft} 
                    wallLength={FLOOR_SIZES[floorIndex].depth}
                    wallHeight={wallHeight}
                    position={[-(FLOOR_SIZES[floorIndex].width/2) + 0.04, wallHeight/2 + 0.06, 0]}
                    rotation={[0, Math.PI/2, 0]}
                  />
                )}
                {/* Forex höger vägg */}
                {graphic === 'forex' && forexImageRight && floorIndex !== null && wallShape === 'u' && (
                  <ForexImageOverlay 
                    imageUrl={forexImageRight} 
                    wallLength={FLOOR_SIZES[floorIndex].depth}
                    wallHeight={wallHeight}
                    position={[(FLOOR_SIZES[floorIndex].width/2) - 0.04, wallHeight/2 + 0.06, 0]}
                    rotation={[0, -Math.PI/2, 0]}
                  />
                )}
                {renderMarkers('back')}
                {renderMarkers('left')}
                {renderMarkers('right')}
                {renderTVs('back')}
                {renderTVs('left')}
                {renderTVs('right')}
                {renderLights('back')}
                {renderLights('left')}
                {renderLights('right')}
                
                {/* Truss-strukturer */}
                {selectedTrussType > 0 && (() => {
                  const trussConfig = TRUSS_TYPES[selectedTrussType];
                  const floor = FLOOR_SIZES[floorIndex];
                  
                  if (trussConfig.type === 'front-straight' && 'width' in trussConfig && 'height' in trussConfig) {
                    // Framkant truss - rak truss längs framkanten av montern
                    const trussLength = floor.width;
                    const numSegments = Math.ceil(trussLength);
                    const trussHeight = wallHeight + 1.0; // Häng på vägghöjd + 1 meter
                    const wireLength = 2.0; // 2 meter vajrar upp till tak
                    
                    return Array.from({length: numSegments}).map((_, i) => {
                      const segLength = i === numSegments - 1 ? trussLength - (numSegments - 1) : 1;
                      const posX = -trussLength/2 + i + segLength/2;
                      const posZ = floor.depth/2 + 0.2; // Lite utanför framkanten
                      
                      return (
                        <group key={`truss-front-${i}`}>
                          {/* Huvudbalk */}
                          <mesh position={[posX, trussHeight, posZ]}>
                            <boxGeometry args={[segLength, trussConfig.height, trussConfig.width]} />
                            <meshStandardMaterial color="#888888" roughness={0.8} metalness={0.3} />
                          </mesh>
                          
                          {/* Vajrar upp till tak */}
                          {Array.from({length: Math.ceil(segLength * 2)}).map((_, wireIndex) => {
                            const wireX = posX + (-segLength/2 + wireIndex * 0.5 + 0.25);
                            if (wireX < posX - segLength/2 || wireX > posX + segLength/2) return null;
                            
                            return (
                              <mesh 
                                key={`wire-${wireIndex}`}
                                position={[wireX, trussHeight + wireLength/2, posZ]} 
                                rotation={[0, 0, 0]}
                              >
                                <cylinderGeometry args={[0.005, 0.005, wireLength, 8]} />
                                <meshStandardMaterial color="#333333" roughness={0.3} metalness={0.8} />
                              </mesh>
                            );
                          })}
                          
                          {/* Spotlights på truss */}
                          {Array.from({length: Math.floor(segLength)}).map((_, lightIndex) => {
                            const lightPosX = posX + (-segLength/2 + lightIndex + 0.5);
                            return (
                              <group key={`light-${lightIndex}`}>
                                <mesh position={[lightPosX, trussHeight - trussConfig.height/2 - 0.15, posZ - trussConfig.width/2 - 0.05]}>
                                  <cylinderGeometry args={[0.08, 0.12, 0.2, 12]} />
                                  <meshStandardMaterial color="#333333" roughness={0.4} metalness={0.6} />
                                </mesh>
                                <spotLight
                                  position={[lightPosX, trussHeight - trussConfig.height/2 - 0.25, posZ - trussConfig.width/2 - 0.05]}
                                  target-position={[lightPosX, 0, posZ - 2]}
                                  intensity={0.8}
                                  angle={Math.PI / 2.5}
                                  penumbra={0.7}
                                  color="#ffffff"
                                  distance={12}
                                  decay={0.8}
                                />
                                <pointLight
                                  position={[lightPosX, trussHeight - trussConfig.height/2 - 0.25, posZ - trussConfig.width/2 - 0.05]}
                                  intensity={0.4}
                                  color="#ffffff"
                                  distance={6}
                                  decay={0.5}
                                />
                              </group>
                            );
                          })}
                        </group>
                      );
                    });
                    
                  } else if (trussConfig.type === 'hanging-round' && 'diameter' in trussConfig && 'height' in trussConfig) {
                    // Rund hängande truss i mitten av montern
                    // Häng på vägghöjd + 1 meter, med vajrar upp till tak
                    const trussHeight = wallHeight + 1.0;
                    const wireLength = 2.0; // 2 meter vajrar upp till tak
                    
                    return (
                      <group key="truss-hanging-round">
                        {/* Huvudring */}
                        <mesh position={[0, trussHeight, 0]} rotation={[Math.PI/2, 0, 0]}>
                          <torusGeometry args={[trussConfig.diameter/2, 0.15, 8, 16]} />
                          <meshStandardMaterial color="#888888" roughness={0.8} metalness={0.3} />
                        </mesh>
                        
                        {/* Vajrar upp till tak */}
                        {Array.from({length: 4}).map((_, i) => {
                          const angle = (i / 4) * Math.PI * 2;
                          const x = Math.cos(angle) * trussConfig.diameter/2;
                          const z = Math.sin(angle) * trussConfig.diameter/2;
                          
                          return (
                            <mesh 
                              key={`wire-${i}`}
                              position={[x, trussHeight + wireLength/2, z]} 
                              rotation={[0, 0, 0]}
                            >
                              <cylinderGeometry args={[0.005, 0.005, wireLength, 8]} />
                              <meshStandardMaterial color="#333333" roughness={0.3} metalness={0.8} />
                            </mesh>
                          );
                        })}
                        
                        {/* Lampor på rund truss */}
                        {Array.from({length: 6}).map((_, i) => {
                          const angle = (i / 6) * Math.PI * 2;
                          const x = Math.cos(angle) * trussConfig.diameter/2 * 0.8;
                          const z = Math.sin(angle) * trussConfig.diameter/2 * 0.8;
                          
                          return (
                            <group key={`light-${i}`}>
                              <mesh position={[x, trussHeight - trussConfig.height/2 - 0.1, z]} rotation={[0, angle + Math.PI/2, 0]}>
                                <cylinderGeometry args={[0.08, 0.12, 0.2, 12]} />
                                <meshStandardMaterial color="#333333" roughness={0.4} metalness={0.6} />
                              </mesh>
                              <spotLight
                                position={[x, trussHeight - trussConfig.height/2 - 0.2, z]}
                                target-position={[x * 0.3, 0, z * 0.3]}
                                intensity={0.7}
                                angle={Math.PI / 3}
                                penumbra={0.8}
                                color="#ffffff"
                                distance={10}
                                decay={0.8}
                              />
                              <pointLight
                                position={[x, trussHeight - trussConfig.height/2 - 0.2, z]}
                                intensity={0.3}
                                color="#ffffff"
                                distance={5}
                                decay={0.6}
                              />
                            </group>
                          );
                        })}
                      </group>
                    );
                    
                  } else if (trussConfig.type === 'hanging-square' && 'width' in trussConfig && 'depth' in trussConfig && 'height' in trussConfig) {
                    // Fyrkantig hängande truss i mitten av montern - justerad storlek för att inte gå in i väggar
                    const trussHeight = wallHeight + 1.0; // Häng på vägghöjd + 1 meter
                    const wireLength = 2.0; // 2 meter vajrar upp till tak
                    const adjustedWidth = Math.min(trussConfig.width, floor.width * 0.6); // Max 60% av monterbredd
                    const adjustedDepth = Math.min(trussConfig.depth, floor.depth * 0.6); // Max 60% av monterdjup
                    
                    return (
                      <group key="truss-hanging-square">
                        {/* Huvudram - fyra sidor */}
                        <mesh position={[0, trussHeight, -adjustedDepth/2]} rotation={[0, 0, 0]}>
                          <boxGeometry args={[adjustedWidth, trussConfig.height, 0.15]} />
                          <meshStandardMaterial color="#888888" roughness={0.8} metalness={0.3} />
                        </mesh>
                        <mesh position={[0, trussHeight, adjustedDepth/2]} rotation={[0, 0, 0]}>
                          <boxGeometry args={[adjustedWidth, trussConfig.height, 0.15]} />
                          <meshStandardMaterial color="#888888" roughness={0.8} metalness={0.3} />
                        </mesh>
                        <mesh position={[-adjustedWidth/2, trussHeight, 0]} rotation={[0, 0, 0]}>
                          <boxGeometry args={[0.15, trussConfig.height, adjustedDepth]} />
                          <meshStandardMaterial color="#888888" roughness={0.8} metalness={0.3} />
                        </mesh>
                        <mesh position={[adjustedWidth/2, trussHeight, 0]} rotation={[0, 0, 0]}>
                          <boxGeometry args={[0.15, trussConfig.height, adjustedDepth]} />
                          <meshStandardMaterial color="#888888" roughness={0.8} metalness={0.3} />
                        </mesh>
                        
                        {/* Vajrar upp till tak */}
                        {[[1,1], [1,-1], [-1,1], [-1,-1]].map(([xSign, zSign], i) => {
                          const x = xSign * adjustedWidth/2 * 0.8;
                          const z = zSign * adjustedDepth/2 * 0.8;
                          
                          return (
                            <mesh 
                              key={`wire-${i}`}
                              position={[x, trussHeight + wireLength/2, z]} 
                              rotation={[0, 0, 0]}
                            >
                              <cylinderGeometry args={[0.005, 0.005, wireLength, 8]} />
                              <meshStandardMaterial color="#333333" roughness={0.3} metalness={0.8} />
                            </mesh>
                          );
                        })}
                        
                        {/* Lampor på fyrkantig truss */}
                        {[
                          {x: 0, z: -adjustedDepth/2 * 0.8, angle: 0},
                          {x: adjustedWidth/2 * 0.8, z: 0, angle: Math.PI/2},
                          {x: 0, z: adjustedDepth/2 * 0.8, angle: Math.PI},
                          {x: -adjustedWidth/2 * 0.8, z: 0, angle: -Math.PI/2},
                        ].map(({x, z, angle}, i) => (
                          <group key={`light-${i}`}>
                            <mesh position={[x, trussHeight - trussConfig.height/2 - 0.1, z]} rotation={[0, angle, 0]}>
                              <cylinderGeometry args={[0.08, 0.12, 0.2, 12]} />
                              <meshStandardMaterial color="#333333" roughness={0.4} metalness={0.6} />
                            </mesh>
                            <spotLight
                              position={[x, trussHeight - trussConfig.height/2 - 0.2, z]}
                              target-position={[x * 0.3, 0, z * 0.3]}
                              intensity={0.7}
                              angle={Math.PI / 3.2}
                              penumbra={0.8}
                              color="#ffffff"
                              distance={10}
                              decay={0.8}
                            />
                            <pointLight
                              position={[x, trussHeight - trussConfig.height/2 - 0.2, z]}
                              intensity={0.3}
                              color="#ffffff"
                              distance={5}
                              decay={0.6}
                            />
                          </group>
                        ))}
                      </group>
                    );
                  }
                  
                  return null;
                })()}
                
                {/* Diskar - visa alla placerade diskar */}
                {counters.map(counter => {
                  const counterConfig = COUNTER_TYPES[counter.type];
                  const counterHeight = 0.9; // 90cm hög disk
                  const counterThickness = 0.05; // 5cm tjock skiva
                  
                  if (counterConfig.type === 'L') {
                    // L-formad disk: 1,5m rakt fram + 1m åt höger
                    return (
                      <group 
                        key={counter.id}
                        position={[counter.position.x, 0, counter.position.z]}
                        rotation={[0, counter.rotation * Math.PI / 180, 0]}
                        onClick={(e) => {
                          e.stopPropagation();
                          setCounters(prev => prev.map(c => 
                            c.id === counter.id 
                              ? {...c, rotation: (c.rotation + 45) % 360}
                              : c
                          ));
                        }}
                        onContextMenu={(e) => {
                          e.stopPropagation();
                          // Högerklick för att ta bort L-disk
                          setCounters(prev => prev.filter(c => c.id !== counter.id));
                        }}
                      >
                        {/* Första delen - rakt fram (1,5m x 0,5m) med hyllor på baksidan */}
                        {/* Vänster sidopanel för första delen */}
                        <mesh position={[-1, counterHeight/2, 0.25]} receiveShadow castShadow>
                          <boxGeometry args={[0.05, counterHeight - counterThickness, 0.5]} />
                          <meshStandardMaterial color={counterPanelColor} roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Frampanel för första delen */}
                        <mesh position={[-0.25, counterHeight/2, 0.475]} receiveShadow castShadow>
                          <boxGeometry args={[1.4, counterHeight - counterThickness, 0.05]} />
                          <meshStandardMaterial 
                            color={counterFrontImage ? "#ffffff" : counterPanelColor} 
                            map={counterTexture}
                            roughness={0.3} 
                            metalness={0.1}
                          />
                        </mesh>
                        
                        {/* Vit baksida för frampanel första delen */}
                        {counterFrontImage && (
                          <mesh position={[-0.25, counterHeight/2, 0.445]} receiveShadow castShadow>
                            <boxGeometry args={[1.4, counterHeight - counterThickness, 0.05]} />
                            <meshStandardMaterial 
                              color="#ffffff"
                              roughness={0.3} 
                              metalness={0.1}
                            />
                          </mesh>
                        )}
                        
                        {/* Första hyllan för första delen */}
                        <mesh position={[-0.25, counterHeight * 0.33, 0.15]} receiveShadow castShadow>
                          <boxGeometry args={[1.3, 0.02, 0.2]} />
                          <meshStandardMaterial 
                            color="#C9955C" 
                            roughness={0.8} 
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur för hyllan
                              const canvas = document.createElement('canvas');
                              canvas.width = 256;
                              canvas.height = 256;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 256, 256);
                              
                              // Träfibrer längsmed hyllan
                              for (let y = 0; y < 256; y += 4) {
                                const variation = Math.sin(y * 0.02) * 10;
                                ctx.strokeStyle = `rgba(${139 + variation}, ${117 + variation}, ${85 + variation}, 0.3)`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(256, y);
                                ctx.stroke();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(2, 1);
                              return texture;
                            })()}
                          />
                        </mesh>
                        
                        {/* Andra hyllan för första delen */}
                        <mesh position={[-0.25, counterHeight * 0.66, 0.15]} receiveShadow castShadow>
                          <boxGeometry args={[1.3, 0.02, 0.2]} />
                          <meshStandardMaterial 
                            color="#C9955C" 
                            roughness={0.8} 
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur för hyllan
                              const canvas = document.createElement('canvas');
                              canvas.width = 256;
                              canvas.height = 256;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 256, 256);
                              
                              // Träfibrer längsmed hyllan
                              for (let y = 0; y < 256; y += 4) {
                                const variation = Math.sin(y * 0.02) * 10;
                                ctx.strokeStyle = `rgba(${139 + variation}, ${117 + variation}, ${85 + variation}, 0.3)`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(256, y);
                                ctx.stroke();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(2, 1);
                              return texture;
                            })()}
                          />
                        </mesh>
                        
                        {/* Botten för första delen */}
                        <mesh position={[-0.25, 0.025, 0.25]} receiveShadow castShadow>
                          <boxGeometry args={[1.5, 0.05, 0.5]} />
                          <meshStandardMaterial color="#ffffff" roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Ekskiva för första delen */}
                        <mesh position={[-0.25, counterHeight - counterThickness/2 + 0.035, 0.25]} receiveShadow castShadow>
                          <boxGeometry args={[1.5, counterThickness, 0.5]} />
                          <meshStandardMaterial 
                            color="#C9955C" // Basek-färg
                            roughness={0.8} // Mer naturlig träyta
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur
                              const canvas = document.createElement('canvas');
                              canvas.width = 512;
                              canvas.height = 512;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 512, 512);
                              
                              // Lägg till träfibrer (horisontella linjer med variation)
                              for (let y = 0; y < 512; y += 8) {
                                const lightness = 0.8 + Math.random() * 0.4;
                                ctx.fillStyle = `rgba(255, 255, 255, ${lightness * 0.15})`;
                                ctx.fillRect(0, y + Math.random() * 4, 512, 2 + Math.random() * 3);
                              }
                              
                              // Lägg till mörkare årsringar
                              for (let i = 0; i < 8; i++) {
                                const y = Math.random() * 512;
                                ctx.fillStyle = `rgba(139, 69, 19, ${0.1 + Math.random() * 0.1})`;
                                ctx.fillRect(0, y, 512, 1 + Math.random() * 2);
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(3, 1); // Sträck ut träfibrerna
                              return texture;
                            })()}
                            normalScale={new THREE.Vector2(0.3, 0.1)} // Subtil normal mapping
                          />
                        </mesh>
                        
                        {/* Andra delen - vinkel åt höger med hyllor på baksidan */}
                        {/* Höger sidopanel för andra delen */}
                        <mesh position={[0.725, counterHeight/2, 0]} receiveShadow castShadow>
                          <boxGeometry args={[0.05, counterHeight - counterThickness, 1]} />
                          <meshStandardMaterial color={counterPanelColor} roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Frampanel för andra delen */}
                        <mesh position={[0.5, counterHeight/2, 0.475]} receiveShadow castShadow>
                          <boxGeometry args={[0.4, counterHeight - counterThickness, 0.05]} />
                          <meshStandardMaterial 
                            color={counterFrontImage ? "#ffffff" : counterPanelColor} 
                            map={counterTexture}
                            roughness={0.3} 
                            metalness={0.1}
                          />
                        </mesh>
                        
                        {/* Vit baksida för frampanel andra delen */}
                        {counterFrontImage && (
                          <mesh position={[0.5, counterHeight/2, 0.445]} receiveShadow castShadow>
                            <boxGeometry args={[0.4, counterHeight - counterThickness, 0.05]} />
                            <meshStandardMaterial 
                              color="#ffffff"
                              roughness={0.3} 
                              metalness={0.1}
                            />
                          </mesh>
                        )}
                        
                        {/* Första hyllan för andra delen */}
                        <mesh position={[0.5, counterHeight * 0.33, -0.35]} receiveShadow castShadow>
                          <boxGeometry args={[0.35, 0.02, 0.2]} />
                          <meshStandardMaterial 
                            color="#C9955C" 
                            roughness={0.8} 
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur för hyllan
                              const canvas = document.createElement('canvas');
                              canvas.width = 256;
                              canvas.height = 256;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 256, 256);
                              
                              // Träfibrer längsmed hyllan
                              for (let y = 0; y < 256; y += 4) {
                                const variation = Math.sin(y * 0.02) * 10;
                                ctx.strokeStyle = `rgba(${139 + variation}, ${117 + variation}, ${85 + variation}, 0.3)`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(256, y);
                                ctx.stroke();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(2, 1);
                              return texture;
                            })()}
                          />
                        </mesh>
                        
                        {/* Andra hyllan för andra delen */}
                        <mesh position={[0.5, counterHeight * 0.66, -0.35]} receiveShadow castShadow>
                          <boxGeometry args={[0.35, 0.02, 0.2]} />
                          <meshStandardMaterial 
                            color="#C9955C" 
                            roughness={0.8} 
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur för hyllan
                              const canvas = document.createElement('canvas');
                              canvas.width = 256;
                              canvas.height = 256;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 256, 256);
                              
                              // Träfibrer längsmed hyllan
                              for (let y = 0; y < 256; y += 4) {
                                const variation = Math.sin(y * 0.02) * 10;
                                ctx.strokeStyle = `rgba(${139 + variation}, ${117 + variation}, ${85 + variation}, 0.3)`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(256, y);
                                ctx.stroke();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(2, 1);
                              return texture;
                            })()}
                          />
                        </mesh>
                        
                        {/* Botten för andra delen */}
                        <mesh position={[0.5, 0.025, 0]} receiveShadow castShadow>
                          <boxGeometry args={[0.5, 0.05, 1]} />
                          <meshStandardMaterial color="#ffffff" roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Ekskiva för andra delen */}
                        <mesh position={[0.5, counterHeight - counterThickness/2 + 0.035, 0]} receiveShadow castShadow>
                          <boxGeometry args={[0.5, counterThickness, 1]} />
                          <meshStandardMaterial 
                            color="#C9955C" // Basek-färg
                            roughness={0.8} // Mer naturlig träyta
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur (roterad för andra delen)
                              const canvas = document.createElement('canvas');
                              canvas.width = 512;
                              canvas.height = 512;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 512, 512);
                              
                              // Lägg till träfibrer (vertikala för denna del)
                              for (let x = 0; x < 512; x += 8) {
                                const lightness = 0.8 + Math.random() * 0.4;
                                ctx.fillStyle = `rgba(255, 255, 255, ${lightness * 0.15})`;
                                ctx.fillRect(x + Math.random() * 4, 0, 2 + Math.random() * 3, 512);
                              }
                              
                              // Lägg till mörkare årsringar
                              for (let i = 0; i < 8; i++) {
                                const x = Math.random() * 512;
                                ctx.fillStyle = `rgba(139, 69, 19, ${0.1 + Math.random() * 0.1})`;
                                ctx.fillRect(x, 0, 1 + Math.random() * 2, 512);
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(1, 3); // Sträck ut träfibrerna vertikalt
                              return texture;
                            })()}
                            normalScale={new THREE.Vector2(0.1, 0.3)} // Subtil normal mapping
                          />
                        </mesh>
                        
                        {/* Objekt på L-disk */}
                        {/* Espressomaskin på den långa delen */}
                        {showEspressoMachine && (
                          <EspressoMachine 
                            position={[-0.5, counterHeight + 0.05, 0.25]} 
                            rotation={0}
                          />
                        )}
                        
                        {/* Vas med blomma på kortsidan */}
                        {showFlowerVase && (
                          <FlowerVase 
                            position={[0.4, counterHeight + 0.05, -0.2]} 
                            rotation={90}
                          />
                        )}
                        
                        {/* Godiskål på hörnet */}
                        {showCandyBowl && (
                          <CandyBowl 
                            position={[0.2, counterHeight + 0.05, 0.1]} 
                            rotation={0}
                          />
                        )}
                      </group>
                    );
                  } else if (counterConfig.type === 'L-mirrored') {
                    // Spegelvänd L-formad disk: 1,5m rakt fram + 1m åt vänster
                    return (
                      <group 
                        key={counter.id}
                        position={[counter.position.x, 0, counter.position.z]}
                        rotation={[0, counter.rotation * Math.PI / 180, 0]}
                        onClick={(e) => {
                          e.stopPropagation();
                          setCounters(prev => prev.map(c => 
                            c.id === counter.id 
                              ? {...c, rotation: (c.rotation + 45) % 360}
                              : c
                          ));
                        }}
                        onContextMenu={(e) => {
                          e.stopPropagation();
                          // Högerklick för att ta bort spegelvänd L-disk
                          setCounters(prev => prev.filter(c => c.id !== counter.id));
                        }}
                      >
                        {/* Första delen - rakt fram (1,5m x 0,5m) med hyllor på baksidan */}
                        {/* Höger sidopanel för första delen */}
                        <mesh position={[1, counterHeight/2, 0.25]} receiveShadow castShadow>
                          <boxGeometry args={[0.05, counterHeight - counterThickness, 0.5]} />
                          <meshStandardMaterial color={counterPanelColor} roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Frampanel för första delen */}
                        <mesh position={[0.25, counterHeight/2, 0.475]} receiveShadow castShadow>
                          <boxGeometry args={[1.4, counterHeight - counterThickness, 0.05]} />
                          <meshStandardMaterial 
                            color={counterFrontImage ? "#ffffff" : counterPanelColor} 
                            map={counterTexture}
                            roughness={0.3} 
                            metalness={0.1}
                          />
                        </mesh>
                        
                        {/* Vit baksida för frampanel första delen */}
                        {counterFrontImage && (
                          <mesh position={[0.25, counterHeight/2, 0.445]} receiveShadow castShadow>
                            <boxGeometry args={[1.4, counterHeight - counterThickness, 0.05]} />
                            <meshStandardMaterial 
                              color="#ffffff"
                              roughness={0.3} 
                              metalness={0.1}
                            />
                          </mesh>
                        )}
                        
                        {/* Första hyllan för första delen */}
                        <mesh position={[0.25, counterHeight * 0.33, 0.15]} receiveShadow castShadow>
                          <boxGeometry args={[1.3, 0.02, 0.2]} />
                          <meshStandardMaterial 
                            color="#C9955C" 
                            roughness={0.8} 
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur för hyllan
                              const canvas = document.createElement('canvas');
                              canvas.width = 256;
                              canvas.height = 256;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 256, 256);
                              
                              // Träfibrer längsmed hyllan
                              for (let y = 0; y < 256; y += 4) {
                                const variation = Math.sin(y * 0.02) * 10;
                                ctx.strokeStyle = `rgba(${139 + variation}, ${117 + variation}, ${85 + variation}, 0.3)`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(256, y);
                                ctx.stroke();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(2, 1);
                              return texture;
                            })()}
                          />
                        </mesh>
                        
                        {/* Andra hyllan för första delen */}
                        <mesh position={[0.25, counterHeight * 0.66, 0.15]} receiveShadow castShadow>
                          <boxGeometry args={[1.3, 0.02, 0.2]} />
                          <meshStandardMaterial 
                            color="#C9955C" 
                            roughness={0.8} 
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur för hyllan
                              const canvas = document.createElement('canvas');
                              canvas.width = 256;
                              canvas.height = 256;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 256, 256);
                              
                              // Träfibrer längsmed hyllan
                              for (let y = 0; y < 256; y += 4) {
                                const variation = Math.sin(y * 0.02) * 10;
                                ctx.strokeStyle = `rgba(${139 + variation}, ${117 + variation}, ${85 + variation}, 0.3)`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(256, y);
                                ctx.stroke();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(2, 1);
                              return texture;
                            })()}
                          />
                        </mesh>
                        
                        {/* Botten för första delen */}
                        <mesh position={[0.25, 0.025, 0.25]} receiveShadow castShadow>
                          <boxGeometry args={[1.5, 0.05, 0.5]} />
                          <meshStandardMaterial color="#ffffff" roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Ekskiva för första delen */}
                        <mesh position={[0.25, counterHeight - counterThickness/2 + 0.035, 0.25]} receiveShadow castShadow>
                          <boxGeometry args={[1.5, counterThickness, 0.5]} />
                          <meshStandardMaterial 
                            color="#C9955C" // Basek-färg
                            roughness={0.8} // Mer naturlig träyta
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur
                              const canvas = document.createElement('canvas');
                              canvas.width = 512;
                              canvas.height = 512;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 512, 512);
                              
                              // Lägg till träfibrer (horisontella linjer med variation)
                              for (let y = 0; y < 512; y += 8) {
                                const lightness = 0.8 + Math.random() * 0.4;
                                ctx.fillStyle = `rgba(255, 255, 255, ${lightness * 0.15})`;
                                ctx.fillRect(0, y + Math.random() * 4, 512, 2 + Math.random() * 3);
                              }
                              
                              // Lägg till mörkare årsringar
                              for (let i = 0; i < 8; i++) {
                                const y = Math.random() * 512;
                                ctx.fillStyle = `rgba(139, 69, 19, ${0.1 + Math.random() * 0.1})`;
                                ctx.fillRect(0, y, 512, 1 + Math.random() * 2);
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(3, 1); // Sträck ut träfibrerna
                              return texture;
                            })()}
                            normalScale={new THREE.Vector2(0.3, 0.1)} // Subtil normal mapping
                          />
                        </mesh>
                        
                        {/* Andra delen - vinkel åt vänster med hyllor på baksidan */}
                        {/* Vänster sidopanel för andra delen */}
                        <mesh position={[-0.725, counterHeight/2, 0]} receiveShadow castShadow>
                          <boxGeometry args={[0.05, counterHeight - counterThickness, 1]} />
                          <meshStandardMaterial color={counterPanelColor} roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Frampanel för andra delen */}
                        <mesh position={[-0.5, counterHeight/2, 0.475]} receiveShadow castShadow>
                          <boxGeometry args={[0.4, counterHeight - counterThickness, 0.05]} />
                          <meshStandardMaterial 
                            color={counterFrontImage ? "#ffffff" : counterPanelColor} 
                            map={counterTexture}
                            roughness={0.3} 
                            metalness={0.1}
                          />
                        </mesh>
                        
                        {/* Vit baksida för frampanel andra delen */}
                        {counterFrontImage && (
                          <mesh position={[-0.5, counterHeight/2, 0.445]} receiveShadow castShadow>
                            <boxGeometry args={[0.4, counterHeight - counterThickness, 0.05]} />
                            <meshStandardMaterial 
                              color="#ffffff"
                              roughness={0.3} 
                              metalness={0.1}
                            />
                          </mesh>
                        )}
                        
                        {/* Första hyllan för andra delen */}
                        <mesh position={[-0.5, counterHeight * 0.33, -0.35]} receiveShadow castShadow>
                          <boxGeometry args={[0.35, 0.02, 0.2]} />
                          <meshStandardMaterial 
                            color="#C9955C" 
                            roughness={0.8} 
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur för hyllan
                              const canvas = document.createElement('canvas');
                              canvas.width = 256;
                              canvas.height = 256;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 256, 256);
                              
                              // Träfibrer längsmed hyllan
                              for (let y = 0; y < 256; y += 4) {
                                const variation = Math.sin(y * 0.02) * 10;
                                ctx.strokeStyle = `rgba(${139 + variation}, ${117 + variation}, ${85 + variation}, 0.3)`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(256, y);
                                ctx.stroke();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(2, 1);
                              return texture;
                            })()}
                          />
                        </mesh>
                        
                        {/* Andra hyllan för andra delen */}
                        <mesh position={[-0.5, counterHeight * 0.66, -0.35]} receiveShadow castShadow>
                          <boxGeometry args={[0.35, 0.02, 0.2]} />
                          <meshStandardMaterial 
                            color="#C9955C" 
                            roughness={0.8} 
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur för hyllan
                              const canvas = document.createElement('canvas');
                              canvas.width = 256;
                              canvas.height = 256;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 256, 256);
                              
                              // Träfibrer längsmed hyllan
                              for (let y = 0; y < 256; y += 4) {
                                const variation = Math.sin(y * 0.02) * 10;
                                ctx.strokeStyle = `rgba(${139 + variation}, ${117 + variation}, ${85 + variation}, 0.3)`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(256, y);
                                ctx.stroke();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(2, 1);
                              return texture;
                            })()}
                          />
                        </mesh>
                        
                        {/* Botten för andra delen */}
                        <mesh position={[-0.5, 0.025, 0]} receiveShadow castShadow>
                          <boxGeometry args={[0.5, 0.05, 1]} />
                          <meshStandardMaterial color="#ffffff" roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Ekskiva för andra delen */}
                        <mesh position={[-0.5, counterHeight - counterThickness/2 + 0.035, 0]} receiveShadow castShadow>
                          <boxGeometry args={[0.5, counterThickness, 1]} />
                          <meshStandardMaterial 
                            color="#C9955C" // Basek-färg
                            roughness={0.8} // Mer naturlig träyta
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur (roterad för andra delen)
                              const canvas = document.createElement('canvas');
                              canvas.width = 512;
                              canvas.height = 512;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 512, 512);
                              
                              // Lägg till träfibrer (vertikala för denna del)
                              for (let x = 0; x < 512; x += 8) {
                                const lightness = 0.8 + Math.random() * 0.4;
                                ctx.fillStyle = `rgba(255, 255, 255, ${lightness * 0.15})`;
                                ctx.fillRect(x + Math.random() * 4, 0, 2 + Math.random() * 3, 512);
                              }
                              
                              // Lägg till mörkare årsringar
                              for (let i = 0; i < 8; i++) {
                                const x = Math.random() * 512;
                                ctx.fillStyle = `rgba(139, 69, 19, ${0.1 + Math.random() * 0.1})`;
                                ctx.fillRect(x, 0, 1 + Math.random() * 2, 512);
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(1, 3); // Sträck ut träfibrerna vertikalt
                              return texture;
                            })()}
                            normalScale={new THREE.Vector2(0.1, 0.3)} // Subtil normal mapping
                          />
                        </mesh>
                        
                        {/* Objekt på spegelvänd L-disk */}
                        {/* Espressomaskin på den långa delen */}
                        {showEspressoMachine && (
                          <EspressoMachine 
                            position={[0.5, counterHeight + 0.05, 0.25]} 
                            rotation={0}
                          />
                        )}
                        
                        {/* Vas med blomma på kortsidan */}
                        {showFlowerVase && (
                          <FlowerVase 
                            position={[-0.4, counterHeight + 0.05, -0.2]} 
                            rotation={-90}
                          />
                        )}
                        
                        {/* Godiskål på hörnet */}
                        {showCandyBowl && (
                          <CandyBowl 
                            position={[-0.2, counterHeight + 0.05, 0.1]} 
                            rotation={0}
                          />
                        )}
                      </group>
                    );
                  } else {
                    // Vanlig rak disk
                    return (
                      <group 
                        key={counter.id}
                        position={[counter.position.x, 0, counter.position.z]}
                        rotation={[0, counter.rotation * Math.PI / 180, 0]}
                        onClick={(e) => {
                          e.stopPropagation();
                          setCounters(prev => prev.map(c => 
                            c.id === counter.id 
                              ? {...c, rotation: (c.rotation + 45) % 360}
                              : c
                          ));
                        }}
                        onContextMenu={(e) => {
                          e.stopPropagation();
                          // Högerklick för att ta bort rak disk
                          setCounters(prev => prev.filter(c => c.id !== counter.id));
                        }}
                      >
                        {/* Diskstruktur med hyllor på baksidan */}
                        {/* Vänster sidopanel */}
                        <mesh position={[-counterConfig.width/2 + 0.025, counterHeight/2, 0]} receiveShadow castShadow>
                          <boxGeometry args={[0.05, counterHeight - counterThickness, counterConfig.depth]} />
                          <meshStandardMaterial color={counterPanelColor} roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Höger sidopanel */}
                        <mesh position={[counterConfig.width/2 - 0.025, counterHeight/2, 0]} receiveShadow castShadow>
                          <boxGeometry args={[0.05, counterHeight - counterThickness, counterConfig.depth]} />
                          <meshStandardMaterial color={counterPanelColor} roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Frampanel (mot besökare) */}
                        <mesh position={[0, counterHeight/2, counterConfig.depth/2 - 0.025]} receiveShadow castShadow>
                          <boxGeometry args={[counterConfig.width - 0.1, counterHeight - counterThickness, 0.05]} />
                          <meshStandardMaterial 
                            color={counterFrontImage ? "#ffffff" : counterPanelColor} 
                            map={counterTexture}
                            roughness={0.3} 
                            metalness={0.1}
                          />
                        </mesh>
                        
                        {/* Vit baksida för frampanel */}
                        {counterFrontImage && (
                          <mesh position={[0, counterHeight/2, counterConfig.depth/2 - 0.055]} receiveShadow castShadow>
                            <boxGeometry args={[counterConfig.width - 0.1, counterHeight - counterThickness, 0.05]} />
                            <meshStandardMaterial 
                              color="#ffffff"
                              roughness={0.3} 
                              metalness={0.1}
                            />
                          </mesh>
                        )}
                        
                        {/* Första hyllan (1/3 höjd) */}
                        <mesh position={[0, counterHeight * 0.33, -counterConfig.depth/2 + 0.15]} receiveShadow castShadow>
                          <boxGeometry args={[counterConfig.width - 0.15, 0.02, counterConfig.depth * 0.4]} />
                          <meshStandardMaterial 
                            color="#C9955C" 
                            roughness={0.8} 
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur för hyllan
                              const canvas = document.createElement('canvas');
                              canvas.width = 256;
                              canvas.height = 256;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 256, 256);
                              
                              // Träfibrer längsmed hyllan
                              for (let y = 0; y < 256; y += 4) {
                                const variation = Math.sin(y * 0.02) * 10;
                                ctx.strokeStyle = `rgba(${139 + variation}, ${117 + variation}, ${85 + variation}, 0.3)`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(256, y);
                                ctx.stroke();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(2, 1);
                              return texture;
                            })()}
                          />
                        </mesh>
                        
                        {/* Andra hyllan (2/3 höjd) */}
                        <mesh position={[0, counterHeight * 0.66, -counterConfig.depth/2 + 0.15]} receiveShadow castShadow>
                          <boxGeometry args={[counterConfig.width - 0.15, 0.02, counterConfig.depth * 0.4]} />
                          <meshStandardMaterial 
                            color="#C9955C" 
                            roughness={0.8} 
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur för hyllan
                              const canvas = document.createElement('canvas');
                              canvas.width = 256;
                              canvas.height = 256;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 256, 256);
                              
                              // Träfibrer längsmed hyllan
                              for (let y = 0; y < 256; y += 4) {
                                const variation = Math.sin(y * 0.02) * 10;
                                ctx.strokeStyle = `rgba(${139 + variation}, ${117 + variation}, ${85 + variation}, 0.3)`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(0, y);
                                ctx.lineTo(256, y);
                                ctx.stroke();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(2, 1);
                              return texture;
                            })()}
                          />
                        </mesh>
                        
                        {/* Botten (för stabilitet) */}
                        <mesh position={[0, 0.025, 0]} receiveShadow castShadow>
                          <boxGeometry args={[counterConfig.width, 0.05, counterConfig.depth]} />
                          <meshStandardMaterial color="#ffffff" roughness={0.3} metalness={0.1} />
                        </mesh>
                        
                        {/* Ekskiva på toppen */}
                        <mesh position={[0, counterHeight - counterThickness/2 + 0.035, 0]} receiveShadow castShadow>
                          <boxGeometry args={[counterConfig.width, counterThickness, counterConfig.depth]} />
                          <meshStandardMaterial 
                            color="#C9955C" // Basek-färg
                            roughness={0.8} // Mer naturlig träyta
                            metalness={0.0}
                            roughnessMap={(() => {
                              // Skapa procedural trästruktur
                              const canvas = document.createElement('canvas');
                              canvas.width = 512;
                              canvas.height = 512;
                              const ctx = canvas.getContext('2d')!;
                              
                              // Basfärg
                              ctx.fillStyle = '#D4A574';
                              ctx.fillRect(0, 0, 512, 512);
                              
                              // Lägg till träfibrer (horisontella linjer med variation)
                              for (let y = 0; y < 512; y += 6) {
                                const lightness = 0.7 + Math.random() * 0.5;
                                const width = 1 + Math.random() * 4;
                                ctx.fillStyle = `rgba(255, 255, 255, ${lightness * 0.12})`;
                                ctx.fillRect(0, y + Math.random() * 3, 512, width);
                                
                                // Lägg till mörkare skuggor för djup
                                ctx.fillStyle = `rgba(101, 67, 33, ${0.08 + Math.random() * 0.05})`;
                                ctx.fillRect(0, y + width, 512, 1);
                              }
                              
                              // Lägg till träfläckar och kvistar
                              for (let i = 0; i < 12; i++) {
                                const x = Math.random() * 512;
                                const y = Math.random() * 512;
                                const size = 8 + Math.random() * 16;
                                ctx.fillStyle = `rgba(101, 67, 33, ${0.15 + Math.random() * 0.1})`;
                                ctx.beginPath();
                                ctx.ellipse(x, y, size, size * 0.3, 0, 0, Math.PI * 2);
                                ctx.fill();
                              }
                              
                              const texture = new THREE.CanvasTexture(canvas);
                              texture.wrapS = THREE.RepeatWrapping;
                              texture.wrapT = THREE.RepeatWrapping;
                              texture.repeat.set(counterConfig.width, counterConfig.depth); // Skala efter diskstorlek
                              return texture;
                            })()}
                            normalScale={new THREE.Vector2(0.2, 0.2)} // Balanserad normal mapping
                          />
                        </mesh>
                        
                        {/* Objekt på disken */}
                        {(counterConfig.width >= 1.5) && (
                          <>
                            {/* Längre diskar - alla objekt med bra placering */}
                            {showEspressoMachine && (
                              <EspressoMachine 
                                position={[-counterConfig.width/2 + 0.25, counterHeight + 0.05, -0.1]} 
                                rotation={0}
                              />
                            )}
                            
                            {showFlowerVase && (
                              <FlowerVase 
                                position={[counterConfig.width/2 - 0.15, counterHeight + 0.05, 0.1]} 
                                rotation={45}
                              />
                            )}
                            
                            {showCandyBowl && (
                              <CandyBowl 
                                position={[
                                  (showEspressoMachine || showFlowerVase) ? 0 : 0,
                                  counterHeight + 0.05, 
                                  (showEspressoMachine || showFlowerVase) ? 0.05 : 0
                                ]} 
                                rotation={0}
                              />
                            )}
                          </>
                        )}
                        
                        {(counterConfig.width < 1.5 && counterConfig.width >= 1) && (
                          <>
                            {/* Kortare diskar - kompakt placering av alla objekt */}
                            {showEspressoMachine && !showFlowerVase && !showCandyBowl && (
                              <EspressoMachine 
                                position={[0, counterHeight + 0.05, 0]} 
                                rotation={0}
                              />
                            )}
                            
                            {showFlowerVase && !showEspressoMachine && !showCandyBowl && (
                              <FlowerVase 
                                position={[0, counterHeight + 0.05, 0]} 
                                rotation={0}
                              />
                            )}
                            
                            {showCandyBowl && !showEspressoMachine && !showFlowerVase && (
                              <CandyBowl 
                                position={[0, counterHeight + 0.05, 0]} 
                                rotation={0}
                              />
                            )}
                            
                            {/* Två objekt - sida vid sida */}
                            {(showEspressoMachine && showFlowerVase && !showCandyBowl) && (
                              <>
                                <EspressoMachine 
                                  position={[-counterConfig.width/4, counterHeight + 0.05, 0]} 
                                  rotation={0}
                                />
                                <FlowerVase 
                                  position={[counterConfig.width/4, counterHeight + 0.05, 0]} 
                                  rotation={0}
                                />
                              </>
                            )}
                            
                            {(showEspressoMachine && showCandyBowl && !showFlowerVase) && (
                              <>
                                <EspressoMachine 
                                  position={[-counterConfig.width/4, counterHeight + 0.05, 0]} 
                                  rotation={0}
                                />
                                <CandyBowl 
                                  position={[counterConfig.width/4, counterHeight + 0.05, 0]} 
                                  rotation={0}
                                />
                              </>
                            )}
                            
                            {(showFlowerVase && showCandyBowl && !showEspressoMachine) && (
                              <>
                                <FlowerVase 
                                  position={[-counterConfig.width/4, counterHeight + 0.05, 0]} 
                                  rotation={0}
                                />
                                <CandyBowl 
                                  position={[counterConfig.width/4, counterHeight + 0.05, 0]} 
                                  rotation={0}
                                />
                              </>
                            )}
                            
                            {/* Alla tre objekt - kompakt arrangering */}
                            {(showEspressoMachine && showFlowerVase && showCandyBowl) && (
                              <>
                                <EspressoMachine 
                                  position={[-counterConfig.width/3, counterHeight + 0.05, -0.05]} 
                                  rotation={0}
                                />
                                <FlowerVase 
                                  position={[0, counterHeight + 0.05, 0.1]} 
                                  rotation={0}
                                />
                                <CandyBowl 
                                  position={[counterConfig.width/3, counterHeight + 0.05, -0.05]} 
                                  rotation={0}
                                />
                              </>
                            )}
                          </>
                        )}
                      </group>
                    );
                  }
                })}

                {/* Förråd - visa alla placerade förråd */}
                {storages.map(storage => {
                  const storageConfig = STORAGE_TYPES[storage.type];
                  const storageHeight = wallHeight; // Samma höjd som väggarna
                  const wallThickness = 0.1; // 10cm tjocka väggar
                  
                  return (
                    <group 
                      key={storage.id}
                      // Lift storage so its bottom sits on top of the floor (floor top = 0.06)
                      position={[storage.position.x, 0.06, storage.position.z]}
                      rotation={[0, storage.rotation * Math.PI / 180, 0]}
                      onClick={(e) => {
                        e.stopPropagation();
                        const floor = FLOOR_SIZES[floorIndex];
                        const newRotation = (storage.rotation + 90) % 360;
                        
                        // Kontrollera om det roterade förrådet skulle gå utanför monterområdet
                        let wouldFitAfterRotation = true;
                        const isRotated = newRotation === 90 || newRotation === 270;
                        const effectiveWidth = isRotated ? storageConfig.depth : storageConfig.width;
                        const effectiveDepth = isRotated ? storageConfig.width : storageConfig.depth;
                        
                        // Kontrollera om förrådet fortfarande passar inom monterområdet efter rotation
                        const maxX = floor.width / 2;
                        const minX = -floor.width / 2;
                        const maxZ = floor.depth / 2; 
                        const minZ = -floor.depth / 2;
                        
                        if (storage.position.x + effectiveWidth/2 > maxX ||
                            storage.position.x - effectiveWidth/2 < minX ||
                            storage.position.z + effectiveDepth/2 > maxZ ||
                            storage.position.z - effectiveDepth/2 < minZ) {
                          wouldFitAfterRotation = false;
                        }
                        
                        // Bara rotera om det passar
                        if (wouldFitAfterRotation) {
                          setStorages(prev => prev.map(s => 
                            s.id === storage.id 
                              ? {...s, rotation: newRotation}
                              : s
                          ));
                        }
                      }}
                      onContextMenu={(e) => {
                        e.stopPropagation();
                        // Högerklick för att ta bort förråd
                        setStorages(prev => prev.filter(s => s.id !== storage.id));
                      }}
                    >
                      {/* Golv (relativt till grupp) - flytta ner så det ligger i botten av förrådet */}
                      <mesh position={[0, -0.03, 0]}>
                        <boxGeometry args={[storageConfig.width, 0.06, storageConfig.depth]} />
                        <meshStandardMaterial color="#ffffff" />
                      </mesh>
                      
                      {/* StorageWall komponent för varje vägg */}
                      <StorageWall
                        position={[0, storageHeight/2, -storageConfig.depth/2 + wallThickness/2]}
                        args={[storageConfig.width, storageHeight, wallThickness]}
                        color={storageColor}
                        image={storageGraphic === 'upload' ? storageUploadedImage : null}
                        wallType="back"
                        selectedWalls={storageWallSelections}
                        storageTexture={storageTexture}
                      />
                      
                      <StorageWall
                        position={[-storageConfig.width/2 + wallThickness/2, storageHeight/2, 0]}
                        args={[wallThickness, storageHeight, storageConfig.depth]}
                        color={storageColor}
                        image={storageGraphic === 'upload' ? storageUploadedImage : null}
                        wallType="left"
                        selectedWalls={storageWallSelections}
                        storageTexture={storageTexture}
                      />
                      
                      <StorageWall
                        position={[storageConfig.width/2 - wallThickness/2, storageHeight/2, 0]}
                        args={[wallThickness, storageHeight, storageConfig.depth]}
                        color={storageColor}
                        image={storageGraphic === 'upload' ? storageUploadedImage : null}
                        wallType="right"
                        selectedWalls={storageWallSelections}
                        storageTexture={storageTexture}
                      />
                      
                      <StorageWall
                        position={[0, storageHeight/2, storageConfig.depth/2 - wallThickness/2]}
                        args={[storageConfig.width, storageHeight, wallThickness]}
                        color={storageColor}
                        image={storageGraphic === 'upload' ? storageUploadedImage : null}
                        wallType="front"
                        selectedWalls={storageWallSelections}
                        storageTexture={storageTexture}
                      />
                      
                    </group>
                  );
                })}

                {/* Växter - visa alla placerade växter */}
                {plants.map(plant => {
                  const plantConfig = PLANT_TYPES[plant.type];
                  
                  return (
                    <group
                      key={plant.id}
                      onClick={(e) => {
                        e.stopPropagation();
                        setPlants(prev => prev.map(p => 
                          p.id === plant.id 
                            ? {...p, rotation: (p.rotation + 90) % 360}
                            : p
                        ));
                      }}
                      onContextMenu={(e) => {
                        e.stopPropagation();
                        // Högerklick för att ta bort växt
                        setPlants(prev => prev.filter(p => p.id !== plant.id));
                      }}
                    >
                      <Plant
                        plantConfig={plantConfig}
                        position={[plant.position.x, 0.065, plant.position.z]}
                        rotation={plant.rotation}
                      />
                    </group>
                  );
                })}

                {/* Möbler - visa alla placerade möbler */}
                {furniture.map(furnitureItem => {
                  const furnitureConfig = FURNITURE_TYPES[furnitureItem.type];
                  
                  return (
                    <group
                      key={furnitureItem.id}
                      onClick={(e) => {
                        e.stopPropagation();
                        // Barstolar (type 'chair') roterar 45°, andra möbler 90°
                        const rotationAmount = furnitureConfig.type === 'chair' ? 45 : 90;
                        setFurniture(prev => prev.map(f => 
                          f.id === furnitureItem.id 
                            ? {...f, rotation: (f.rotation + rotationAmount) % 360}
                            : f
                        ));
                      }}
                      onContextMenu={(e) => {
                        e.stopPropagation();
                        // Högerklick för att ta bort möbel
                        setFurniture(prev => prev.filter(f => f.id !== furnitureItem.id));
                      }}
                    >
                      <Furniture
                        furnitureConfig={furnitureConfig}
                        position={[furnitureItem.position.x, 0.065, furnitureItem.position.z]}
                        rotation={furnitureItem.rotation}
                      />
                    </group>
                  );
                })}

                {/* LED-lampor på förrådsväggarnas utsidor (framsida + sida närmast mitten) */}
                {showLights && storages.map(storage => {
                  const storageConfig = STORAGE_TYPES[storage.type];
                  const isRotated = storage.rotation === 90 || storage.rotation === 270;
                  const effectiveWidth = isRotated ? storageConfig.depth : storageConfig.width;
                  const effectiveDepth = isRotated ? storageConfig.width : storageConfig.depth;
                  
                  const storageLights = [];
                  
                  // Lampor på förrådets framsida (öppning mot montern)
                  const numLightsFront = Math.floor(effectiveWidth);
                  for (let i = 0; i < numLightsFront; i++) {
                    const lightX = storage.position.x + (-effectiveWidth/2 + i + 0.5);
                    const lightZ = storage.position.z + (effectiveDepth/2 + 0.15); // Utanför förrådets framsida
                    
                    storageLights.push(
                      <group key={`storage-${storage.id}-front-${i}`}>
                        {/* Lampram */}
                        <mesh 
                          position={[lightX, wallHeight + 0.07, lightZ]}
                          rotation={[0, 0, 0]}
                        >
                          <boxGeometry args={[0.06, 0.015, 0.3]} />
                          <meshStandardMaterial color="#999" />
                        </mesh>
                        
                        {/* LED-strip */}
                        <mesh 
                          position={[lightX, wallHeight + 0.065, lightZ]}
                          rotation={[0, 0, 0]}
                        >
                          <boxGeometry args={[0.05, 0.008, 0.25]} />
                          <meshStandardMaterial 
                            color="#ffffff" 
                            emissive="#ffffff" 
                            emissiveIntensity={1.2}
                          />
                        </mesh>
                        
                        {/* Belysning riktad in mot montern */}
                        <spotLight
                          position={[lightX, wallHeight + 0.06, lightZ]}
                          target-position={[lightX, 0, lightZ - 1]}
                          intensity={0.3}
                          angle={Math.PI / 2.5}
                          penumbra={0.9}
                          color="#e8f4fd"
                          distance={4}
                          decay={1}
                        />
                        
                        <pointLight
                          position={[lightX, wallHeight - 0.4, lightZ - 0.5]}
                          intensity={0.25}
                          color="#e8f4fd"
                          distance={3}
                          decay={0.3}
                        />
                      </group>
                    );
                  }
                  
                  // Bestäm vilken sida som är närmast mitten av montern
                  const storageLeftX = storage.position.x - effectiveWidth/2;
                  const storageRightX = storage.position.x + effectiveWidth/2;
                  const centerX = 0; // Mitten av montern är vid X=0
                  
                  // Kontrollera vilket håll som är närmare mitten
                  const leftDistanceToCenter = Math.abs(storageLeftX - centerX);
                  const rightDistanceToCenter = Math.abs(storageRightX - centerX);
                  
                  // Placera lampor på den sida som är närmast mitten
                  const useLightSide = leftDistanceToCenter < rightDistanceToCenter ? 'left' : 'right';
                  
                  // Lampor på sidan närmast mitten
                  const numLightsSide = Math.floor(effectiveDepth);
                  for (let i = 0; i < numLightsSide; i++) {
                    let lightX, lightTargetX, lightPointX, rotation;
                    const lightZ = storage.position.z + (-effectiveDepth/2 + i + 0.5);
                    
                    if (useLightSide === 'left') {
                      // Vänster sida - placera utanför vänster vägg, lyser högerut
                      lightX = storage.position.x + (-effectiveWidth/2 - 0.15);
                      lightTargetX = lightX + 1;
                      lightPointX = lightX + 0.5;
                      rotation = [0, Math.PI/2, 0];
                    } else {
                      // Höger sida - placera utanför höger vägg, lyser vänsterut  
                      lightX = storage.position.x + (effectiveWidth/2 + 0.15);
                      lightTargetX = lightX - 1;
                      lightPointX = lightX - 0.5;
                      rotation = [0, -Math.PI/2, 0];
                    }
                    
                    storageLights.push(
                      <group key={`storage-${storage.id}-side-${i}`}>
                        {/* Lampram */}
                        <mesh 
                          position={[lightX, wallHeight + 0.07, lightZ]}
                          rotation={rotation as [number, number, number]}
                        >
                          <boxGeometry args={[0.06, 0.015, 0.3]} />
                          <meshStandardMaterial color="#999" />
                        </mesh>
                        
                        {/* LED-strip */}
                        <mesh 
                          position={[lightX, wallHeight + 0.065, lightZ]}
                          rotation={rotation as [number, number, number]}
                        >
                          <boxGeometry args={[0.05, 0.008, 0.25]} />
                          <meshStandardMaterial 
                            color="#ffffff" 
                            emissive="#ffffff" 
                            emissiveIntensity={1.2}
                          />
                        </mesh>
                        
                        {/* Belysning riktad mot mitten av montern */}
                        <spotLight
                          position={[lightX, wallHeight + 0.06, lightZ]}
                          target-position={[lightTargetX, 0, lightZ]}
                          intensity={0.3}
                          angle={Math.PI / 2.5}
                          penumbra={0.9}
                          color="#e8f4fd"
                          distance={4}
                          decay={1}
                        />
                        
                        <pointLight
                          position={[lightPointX, wallHeight - 0.4, lightZ]}
                          intensity={0.25}
                          color="#e8f4fd"
                          distance={3}
                          decay={0.3}
                        />
                      </group>
                    );
                  }
                  
                  return storageLights;
                })}
              </>;
              // All logik för markers och TV hanteras nu av renderMarkers/renderTVs för alla väggar
            })()}

            {/* Väggmarkörer för hyllor */}
            {shelfMarkersVisible && wallShape && wallShape !== '' && (() => {
              const floor = FLOOR_SIZES[floorIndex];
              const wallMarkers = [];
              const markerSize = 0.5; // 4 per kvm = 0.5m avstånd
              
              // Bakvägg markörer - placera på väggen (inte framkanten)
              if (wallShape === 'straight' || wallShape === 'l' || wallShape === 'u') {
                for (let x = -floor.width/2 + markerSize/2; x < floor.width/2; x += markerSize) {
                  for (let y = markerSize; y < wallHeight; y += markerSize) {
                    wallMarkers.push(
                      <mesh 
                        key={`wall-marker-back-${x}-${y}`}
                        position={[x, y, -floor.depth/2 + 0.02]}
                        onClick={(e) => {
                          e.stopPropagation();
                          setWallShelves(prev => [...prev, {
                            id: nextShelfId,
                            wall: 'back',
                            position: { x, y }
                          }]);
                          setNextShelfId(prev => prev + 1);
                        }}
                      >
                        <boxGeometry args={[0.2, 0.2, 0.03]} />
                        <meshStandardMaterial color="#00ff00" transparent opacity={0.8} />
                      </mesh>
                    );
                  }
                }
              }
              
              // Vänster vägg markörer - placera på väggen
              if (wallShape === 'l' || wallShape === 'u') {
                for (let z = -floor.depth/2 + markerSize/2; z < floor.depth/2; z += markerSize) {
                  for (let y = markerSize; y < wallHeight; y += markerSize) {
                    wallMarkers.push(
                      <mesh 
                        key={`wall-marker-left-${z}-${y}`}
                        position={[-floor.width/2 + 0.02, y, z]}
                        onClick={(e) => {
                          e.stopPropagation();
                          setWallShelves(prev => [...prev, {
                            id: nextShelfId,
                            wall: 'left',
                            position: { x: z, y }
                          }]);
                          setNextShelfId(prev => prev + 1);
                        }}
                      >
                        <boxGeometry args={[0.03, 0.2, 0.2]} />
                        <meshStandardMaterial color="#00ff00" transparent opacity={0.8} />
                      </mesh>
                    );
                  }
                }
              }
              
              // Höger vägg markörer (för U-form) - placera på väggen
              if (wallShape === 'u') {
                for (let z = -floor.depth/2 + markerSize/2; z < floor.depth/2; z += markerSize) {
                  for (let y = markerSize; y < wallHeight; y += markerSize) {
                    wallMarkers.push(
                      <mesh 
                        key={`wall-marker-right-${z}-${y}`}
                        position={[floor.width/2 - 0.02, y, z]}
                        onClick={(e) => {
                          e.stopPropagation();
                          setWallShelves(prev => [...prev, {
                            id: nextShelfId,
                            wall: 'right',
                            position: { x: z, y }
                          }]);
                          setNextShelfId(prev => prev + 1);
                        }}
                      >
                        <boxGeometry args={[0.03, 0.2, 0.2]} />
                        <meshStandardMaterial color="#00ff00" transparent opacity={0.8} />
                      </mesh>
                    );
                  }
                }
              }
              
              // Förrådsväggar markörer - alla fyra sidor av varje förråd
              storages.forEach(storage => {
                const storageConfig = STORAGE_TYPES[storage.type];
                if (storageConfig.width === 0) return;
                
                const storageWidth = storageConfig.width;
                const storageDepth = storageConfig.depth;
                
                // Förrådets bakvägg (längst från montern)
                for (let x = -storageWidth/2 + markerSize/2; x < storageWidth/2; x += markerSize) {
                  for (let y = markerSize; y < wallHeight; y += markerSize) {
                    const worldX = storage.position.x + x * Math.cos((storage.rotation * Math.PI) / 180) - (storageDepth/2) * Math.sin((storage.rotation * Math.PI) / 180);
                    const worldZ = storage.position.z + x * Math.sin((storage.rotation * Math.PI) / 180) + (storageDepth/2) * Math.cos((storage.rotation * Math.PI) / 180);
                    
                    wallMarkers.push(
                      <mesh 
                        key={`storage-marker-back-${storage.id}-${x}-${y}`}
                        position={[worldX, y, worldZ + 0.02]}
                        onClick={(e) => {
                          e.stopPropagation();
                          setWallShelves(prev => [...prev, {
                            id: nextShelfId,
                            wall: `storage-${storage.id}-back`,
                            position: { x, y }
                          }]);
                          setNextShelfId(prev => prev + 1);
                        }}
                      >
                        <boxGeometry args={[0.15, 0.15, 0.03]} />
                        <meshStandardMaterial color="#ffaa00" transparent opacity={0.8} />
                      </mesh>
                    );
                  }
                }
                
                // Förrådets vänstra vägg
                for (let z = -storageDepth/2 + markerSize/2; z < storageDepth/2; z += markerSize) {
                  for (let y = markerSize; y < wallHeight; y += markerSize) {
                    const worldX = storage.position.x + (-storageWidth/2) * Math.cos((storage.rotation * Math.PI) / 180) - z * Math.sin((storage.rotation * Math.PI) / 180);
                    const worldZ = storage.position.z + (-storageWidth/2) * Math.sin((storage.rotation * Math.PI) / 180) + z * Math.cos((storage.rotation * Math.PI) / 180);
                    
                    wallMarkers.push(
                      <mesh 
                        key={`storage-marker-left-${storage.id}-${z}-${y}`}
                        position={[worldX - 0.02, y, worldZ]}
                        onClick={(e) => {
                          e.stopPropagation();
                          setWallShelves(prev => [...prev, {
                            id: nextShelfId,
                            wall: `storage-${storage.id}-left`,
                            position: { x: z, y }
                          }]);
                          setNextShelfId(prev => prev + 1);
                        }}
                      >
                        <boxGeometry args={[0.03, 0.15, 0.15]} />
                        <meshStandardMaterial color="#ffaa00" transparent opacity={0.8} />
                      </mesh>
                    );
                  }
                }
                
                // Förrådets högra vägg
                for (let z = -storageDepth/2 + markerSize/2; z < storageDepth/2; z += markerSize) {
                  for (let y = markerSize; y < wallHeight; y += markerSize) {
                    const worldX = storage.position.x + (storageWidth/2) * Math.cos((storage.rotation * Math.PI) / 180) - z * Math.sin((storage.rotation * Math.PI) / 180);
                    const worldZ = storage.position.z + (storageWidth/2) * Math.sin((storage.rotation * Math.PI) / 180) + z * Math.cos((storage.rotation * Math.PI) / 180);
                    
                    wallMarkers.push(
                      <mesh 
                        key={`storage-marker-right-${storage.id}-${z}-${y}`}
                        position={[worldX + 0.02, y, worldZ]}
                        onClick={(e) => {
                          e.stopPropagation();
                          setWallShelves(prev => [...prev, {
                            id: nextShelfId,
                            wall: `storage-${storage.id}-right`,
                            position: { x: z, y }
                          }]);
                          setNextShelfId(prev => prev + 1);
                        }}
                      >
                        <boxGeometry args={[0.03, 0.15, 0.15]} />
                        <meshStandardMaterial color="#ffaa00" transparent opacity={0.8} />
                      </mesh>
                    );
                  }
                }
              });
              
              return wallMarkers;
            })()}

            {/* Placerade hyllor */}
            {wallShelves.map(shelf => {
              const floor = FLOOR_SIZES[floorIndex];
              let shelfPosition: [number, number, number] = [0, 0, 0];
              let shelfRotation: [number, number, number] = [0, 0, 0];
              
              if (shelf.wall === 'back') {
                shelfPosition = [shelf.position.x, shelf.position.y, -floor.depth/2];
              } else if (shelf.wall === 'left') {
                shelfPosition = [-floor.width/2, shelf.position.y, shelf.position.x];
                shelfRotation = [0, Math.PI/2, 0];
              } else if (shelf.wall === 'right') {
                shelfPosition = [floor.width/2, shelf.position.y, shelf.position.x];
                shelfRotation = [0, -Math.PI/2, 0];
              } else if (shelf.wall.startsWith('storage-')) {
                // Hantera förrådsväggar
                const storageId = parseInt(shelf.wall.split('-')[1]);
                const side = shelf.wall.split('-')[2];
                const storage = storages.find(s => s.id === storageId);
                
                if (storage) {
                  const storageConfig = STORAGE_TYPES[storage.type];
                  const storageWidth = storageConfig.width;
                  const storageDepth = storageConfig.depth;
                  
                  // Beräkna position baserat på förrådets position och rotation
                  const storageRad = (storage.rotation * Math.PI) / 180;
                  
                  if (side === 'back') {
                    const localX = shelf.position.x;
                    shelfPosition = [
                      storage.position.x + localX * Math.cos(storageRad) - (storageDepth/2) * Math.sin(storageRad),
                      shelf.position.y,
                      storage.position.z + localX * Math.sin(storageRad) + (storageDepth/2) * Math.cos(storageRad)
                    ];
                    shelfRotation = [0, storage.rotation * Math.PI / 180, 0];
                  } else if (side === 'left') {
                    const localZ = shelf.position.x;
                    shelfPosition = [
                      storage.position.x + (-storageWidth/2) * Math.cos(storageRad) - localZ * Math.sin(storageRad),
                      shelf.position.y,
                      storage.position.z + (-storageWidth/2) * Math.sin(storageRad) + localZ * Math.cos(storageRad)
                    ];
                    shelfRotation = [0, (storage.rotation + 90) * Math.PI / 180, 0];
                  } else if (side === 'right') {
                    const localZ = shelf.position.x;
                    shelfPosition = [
                      storage.position.x + (storageWidth/2) * Math.cos(storageRad) - localZ * Math.sin(storageRad),
                      shelf.position.y,
                      storage.position.z + (storageWidth/2) * Math.sin(storageRad) + localZ * Math.cos(storageRad)
                    ];
                    shelfRotation = [0, (storage.rotation - 90) * Math.PI / 180, 0];
                  }
                } else {
                  // Fallback om förrådsobjektet inte hittas
                  shelfPosition = [shelf.position.x, shelf.position.y, 0];
                }
              } else {
                // Fallback för okända väggar
                shelfPosition = [shelf.position.x, shelf.position.y, 0];
              }
              
              return (
                <group
                  key={shelf.id}
                  onClick={(e) => {
                    e.stopPropagation();
                    // Högerklick för att ta bort hylla
                    setWallShelves(prev => prev.filter(s => s.id !== shelf.id));
                  }}
                >
                  <WallShelf
                    position={shelfPosition}
                    rotation={shelfRotation}
                    width={0.6}
                  />
                </group>
              );
            })}

            {/* Golvmarkörer för högtalare */}
            {speakerMarkersVisible && (() => {
              const floor = FLOOR_SIZES[floorIndex];
              const floorMarkers = [];
              const markerSize = 0.5; // 4 per kvadratmeter = 0.5m avstånd
              
              for (let x = -floor.width/2 + markerSize/2; x < floor.width/2; x += markerSize) {
                for (let z = -floor.depth/2 + markerSize/2; z < floor.depth/2; z += markerSize) {
                  // Undvik områden där det finns diskar eller förråd
                  const tooCloseToCounter = counters.some(counter => {
                    const counterConfig = COUNTER_TYPES[counter.type];
                    if (counterConfig.width === 0) return false;
                    const dx = Math.abs(x - counter.position.x);
                    const dz = Math.abs(z - counter.position.z);
                    return dx < 1.0 && dz < 1.0;
                  });
                  
                  const tooCloseToStorage = storages.some(storage => {
                    const storageConfig = STORAGE_TYPES[storage.type];
                    if (storageConfig.width === 0) return false;
                    const dx = Math.abs(x - storage.position.x);
                    const dz = Math.abs(z - storage.position.z);
                    return dx < 1.0 && dz < 1.0;
                  });
                  
                  // Kontrollera om det redan finns en högtalare här
                  const speakerExists = speakers.some(speaker => {
                    const dx = Math.abs(x - speaker.position.x);
                    const dz = Math.abs(z - speaker.position.z);
                    return dx < 0.3 && dz < 0.3;
                  });
                  
                  if (!tooCloseToCounter && !tooCloseToStorage && !speakerExists) {
                    floorMarkers.push(
                      <mesh 
                        key={`speaker-marker-${x}-${z}`}
                        position={[x, 0.06, z]}
                        onClick={(e) => {
                          e.stopPropagation();
                          setSpeakers(prev => [...prev, {
                            id: nextSpeakerId,
                            position: { x, z },
                            rotation: 0
                          }]);
                          setNextSpeakerId(prev => prev + 1);
                        }}
                        onPointerOver={() => {
                          document.body.style.cursor = 'pointer';
                        }}
                        onPointerOut={() => {
                          document.body.style.cursor = 'default';
                        }}
                      >
                        <boxGeometry args={[0.15, 0.03, 0.15]} />
                        <meshStandardMaterial 
                          color="#4444ff" 
                          transparent 
                          opacity={0.8}
                          emissive="#2222bb"
                          emissiveIntensity={0.2}
                        />
                      </mesh>
                    );
                  }
                }
              }
              
              return floorMarkers;
            })()}

            {/* Placerade högtalare */}
            {speakers.map(speaker => (
              <group
                key={speaker.id}
                onClick={(e) => {
                  e.stopPropagation();
                  // Rotera högtalare vid klick
                  setSpeakers(prev => prev.map(s => 
                    s.id === speaker.id 
                      ? {...s, rotation: (s.rotation + 45) % 360}
                      : s
                  ));
                }}
                onContextMenu={(e) => {
                  e.stopPropagation();
                  // Högerklick för att ta bort högtalare
                  setSpeakers(prev => prev.filter(s => s.id !== speaker.id));
                }}
                onPointerOver={() => {
                  document.body.style.cursor = 'pointer';
                }}
                onPointerOut={() => {
                  document.body.style.cursor = 'default';
                }}
              >
                <SpeakerOnStand
                  position={[speaker.position.x, 0, speaker.position.z]}
                  rotation={[0, (speaker.rotation * Math.PI) / 180, 0]}
                  size={speakerSize}
                />
              </group>
            ))}

            {/* Klädhängare i förråd */}
            {showClothingRacks && storages.map(storage => {
              const storageConfig = STORAGE_TYPES[storage.type];
              if (storageConfig.width === 0) return null;
              
              // Placera klädhängare i mitten av förrådet
              return (
                <ClothingRack 
                  key={`clothing-rack-${storage.id}`}
                  position={[storage.position.x, 0, storage.position.z]} 
                  rotation={[0, (storage.rotation * Math.PI) / 180, 0]}
                  height={1.6}
                />
              );
            })}
            
            <OrbitControls />
          </Canvas>
          );
        })()}
      </div>
    </div>
  );
}


